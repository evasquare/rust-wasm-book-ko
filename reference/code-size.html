<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>.wasm 파일 사이즈 줄이기 - Rust and WebAssembly</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> 소개</a></li><li class="chapter-item expanded "><a href="../why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> 왜 Rust로 WebAssembly 개발을 해야 하나요?</a></li><li class="chapter-item expanded "><a href="../background-and-concepts.html"><strong aria-hidden="true">3.</strong> 배경 지식</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> WebAssembly가 뭔가요?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> 튜토리얼</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> 셋업</a></li><li class="chapter-item expanded "><a href="../game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="../game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> 규칙</a></li><li class="chapter-item expanded "><a href="../game-of-life/implementing.html"><strong aria-hidden="true">4.4.</strong> Game of Life 구현하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> Game of Life 테스팅하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> 디버깅</a></li><li class="chapter-item expanded "><a href="../game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> 상호작용 추가하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/time-profiling.html"><strong aria-hidden="true">4.8.</strong> 타임 프로파일링</a></li><li class="chapter-item expanded "><a href="../game-of-life/code-size.html"><strong aria-hidden="true">4.9.</strong> .wasm 파일 사이즈 줄이기</a></li><li class="chapter-item expanded "><a href="../game-of-life/publishing-to-npm.html"><strong aria-hidden="true">4.10.</strong> npm에 배포하기</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">5.</strong> 레퍼런스</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/crates.html"><strong aria-hidden="true">5.1.</strong> 알면 좋은 크레이트들</a></li><li class="chapter-item expanded "><a href="../reference/tools.html"><strong aria-hidden="true">5.2.</strong> 알면 좋은 툴들</a></li><li class="chapter-item expanded "><a href="../reference/project-templates.html"><strong aria-hidden="true">5.3.</strong> 프로젝트 템플릿</a></li><li class="chapter-item expanded "><a href="../reference/debugging.html"><strong aria-hidden="true">5.4.</strong> 디버깅</a></li><li class="chapter-item expanded "><a href="../reference/time-profiling.html"><strong aria-hidden="true">5.5.</strong> 타임 프로파일링</a></li><li class="chapter-item expanded "><a href="../reference/code-size.html" class="active"><strong aria-hidden="true">5.6.</strong> .wasm 파일 사이즈 줄이기</a></li><li class="chapter-item expanded "><a href="../reference/js-ffi.html"><strong aria-hidden="true">5.7.</strong> JavaScript 상호 운용하기</a></li><li class="chapter-item expanded "><a href="../reference/which-crates-work-with-wasm.html"><strong aria-hidden="true">5.8.</strong> 어떤 Rust 크레이트들을 WebAssembly에서 바로 사용할수 있나요?</a></li><li class="chapter-item expanded "><a href="../reference/add-wasm-support-to-crate.html"><strong aria-hidden="true">5.9.</strong> 다목적 크레이트가 WebAssembly를 지원하도록 코드 추가하기</a></li><li class="chapter-item expanded "><a href="../reference/deploying-to-production.html"><strong aria-hidden="true">5.10.</strong> Rust와 WebAssembly 코드를 실제 환경에 배포하기</a></li><li class="chapter-item expanded "><a href="../reference/translations.html"><strong aria-hidden="true">5.11.</strong> 번역본</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="wasm-파일-사이즈-줄이기"><a class="header" href="#wasm-파일-사이즈-줄이기"><code>.wasm</code> 파일 사이즈 줄이기</a></h1>
<p>이 섹션에서는 어떻게 <code>.wasm</code> 빌드를 최적화해서 더 작은 공간을 차지하도록 하고 더 작은 <code>.wasm</code> 파일이 출력되도록 Rust 코드를 수정해야 하는지 알아보겠습니다.</p>
<h2 id="왜-출력되는-파일의-사이즈가-중요한가요"><a class="header" href="#왜-출력되는-파일의-사이즈가-중요한가요">왜 출력되는 파일의 사이즈가 중요한가요?</a></h2>
<p><code>.wasm</code> 파일을 네트워크로 전송할 때, 파일의 사이즈가 작을수록 클라이언트에서 더 빠르게 다운로드 할수 있게 됩니다. <code>.wasm</code> 파일이 빨리 다운로드 되면 페이지를 더 빨리 로드할수 있고, 유저 경험이 더 나아집니다.</p>
<p>하지만 코드 사이즈가 가장 중요하게 확인해야 할 부분은 아닙니다. 모호하고 측정하기 어렵지만 "페이지가 로드되고 사용할 수 있게 될 때까지 걸리는 시간"이 사실 더 중요할수도 있습니다. 코드 사이즈가 이 시간에 큰 영향을 미치지만 (코드가 로드돼야 사이트가 작동하기 시작한다는 내용을 생각하면) 이게 유일하게 확인해야 할 부분은 아닙니다.</p>
<p>WebAssembly는 보통 gzip 파일 포맷 형식으로 압축돼서 전송되기 때문에, 유선을 통해 파일을 더 빠르게 보낼수 있도록 gzip 포맷으로 압축된 파일의 사이즈를 비교해야 합니다. 참고로, WebAssembly 바이너리 포맷은 gzip 포맷에 적합하므로 50% 이상으로 사이즈를 줄일 수 있습니다.</p>
<p>게다가, WebAssembly의 바이너리 포맷은 매우 빠르게 읽고 처리할수 있도록 최적화가 잘 돼있습니다. 요즘 사용하는 브라우저들은 보통 "baseline compilers" 라는 기능을 포함하는데, 이 기능을 통해 네트워크로 wasm 파일을 보낸 것만큼 빠르게 전송받은 WebAssembly 코드를 기계어로 컴파일할 수 있습니다. 그렇기 때문에 <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/"><code>instantiateStreaming</code>을 사용한다면</a> 웹페이지가 한 번 로드 된 이후부터 WebAssembly 모듈을 바로 사용할 수 있게 됩니다. 반면에 JavaScript 코드를 실행할 때는 주로 파싱 하는 것 외에도 코드를 빠르게 실행할수 있도록 JIT 컴파일 과정 등을 거쳐야 하기 때문에 시간이 더 오래 걸릴수도 있습니다.</p>
<p>그리고 마지막으로, WebAssembly가 실행 속도 측면에서 JavaScript와 비교했을때도 훨씬 최적화가 잘 돼있다는 부분을 기억해주세요. JavaScript와 WebAssembly 런타임 속도를 각각 측정해보고 코드 사이즈가 얼마나 중요한지 확인해볼수도 있습니다.</p>
<p>하지만 <code>.wasm</code> 파일의 사이즈가 예상보다 크더라도 바로 낙담하지는 말아주세요! 코드 사이즈는 큰 그림의 일부일 뿐입니다. JavaScript와 WebAssembly를 비교할 때 코드 사이즈만 비교하게 된다면 많은 부분을 놓치게 됩니다.</p>
<h2 id="코드-사이즈를-줄일-수-있도록-빌드-최적화하기"><a class="header" href="#코드-사이즈를-줄일-수-있도록-빌드-최적화하기">코드 사이즈를 줄일 수 있도록 빌드 최적화하기</a></h2>
<p><code>rustc</code>가 더 작은 <code>.wasm</code> 바이너리를 생성할 수 있도록 설정해볼수 있는 옵션이 몇 가지 있습니다. 어떤 상황에서는, 컴파일 시간이 더 오래 걸리는 부분을 희생해서 <code>.wasm</code> 사이즈를 더 작게 줄이기도 합니다. 또 다른 경우에는, 더 빠른 런타임을 위해 <code>.wasm</code> 파일 사이즈를 포기하기도 합니다. 각 옵션의 장단점을 잘 이해하고, 프로파일링과 측정을 해보면서 코드 사이즈와 런타임 속도 중 어떤 것이 더 중요한지 잘 알고 결정하는 것이 중요합니다.</p>
<h3 id="링크-시간-최적화-link-time-optimizations-lto-을-사용해서-컴파일하기"><a class="header" href="#링크-시간-최적화-link-time-optimizations-lto-을-사용해서-컴파일하기">링크 시간 최적화 (Link Time Optimizations, LTO) 을 사용해서 컴파일하기</a></h3>
<p><code>Cargo.toml</code> 파일의 <code>[profile.release]</code> 섹션에 <code>lto = true</code>를 추가해주세요:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<p>이렇게 LLVML이 사용하지 않는 코드를 더 많이 제거하고 인라인 작업을 더 적극적으로 처리할 수 있도록 설정할 수 있습니다. <code>.wasm</code> 파일의 사이즈가 작아질 뿐 아니라, 런타임을 더 빠르게 만들수도 있습니다! 하지만 컴파일 작업이 더 오래 걸린다는 단점이 있으니 참고해주세요.</p>
<h3 id="런타임-속도-대신-코드-사이즈를-최적화하도록-llvm-설정하기"><a class="header" href="#런타임-속도-대신-코드-사이즈를-최적화하도록-llvm-설정하기">런타임 속도 대신 코드 사이즈를 최적화하도록 LLVM 설정하기</a></h3>
<p>LLVM의 최적화 작업은 기본적으로는 사이즈 대신 속도 개선에 중점을 두고 진행됩니다. <code>[profile.release]</code>파일의 <code>[profile.release]</code> 섹션을 수정하여 이 설정을 변경할 수 있습니다:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>추가로 발생할 수 있는 속도 저하를 감수해서라도 더 공격적으로 최적화를 해볼수도 있습니다:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>정말 놀랍게도, 출력되는 파일의 사이즈가 <code>opt-level = "z"</code>대신 <code>opt-level = "s"</code>를 사용했을 때 더 작아지는 경우도 있습니다. 항상 확인해보는걸 잊지 말아주세요!</p>
<h3 id="wasm-opt-툴-사용하기"><a class="header" href="#wasm-opt-툴-사용하기"><code>wasm-opt</code> 툴 사용하기</a></h3>
<p><a href="https://github.com/WebAssembly/binaryen">Binaryen</a> 툴킷은 WebAssembly에 특화된 컴파일러 툴들을 포함합니다. 단순히 LLVM의 WebAssembly 백엔드 작업 외에도 훨씬 더 많은 작업에 사용할 수 있고, <code>wasm-opt</code>툴을 사용해서 LLVM이 생성한 <code>.wasm</code> 바이너리를 빌드 이후에 최적화 하면 보통은 코드 사이즈를 15-20% 정도 더 줄일수 있게 됩니다. 참고로 런타임 속도도 동시에 개선이 되니 참고해주세요!</p>
<pre><code class="language-bash"># 사이즈 최적화.
wasm-opt -Os -o output.wasm input.wasm

# 공격적인 사이즈 최적화.
wasm-opt -Oz -o output.wasm input.wasm

# 속도 최적화.
wasm-opt -O -o output.wasm input.wasm

# 공격적인 속도 최적화.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<h3 id="디버그-정보에-관해-알아두면-좋은-점"><a class="header" href="#디버그-정보에-관해-알아두면-좋은-점">디버그 정보에 관해 알아두면 좋은 점</a></h3>
<p>wasm 바이너리 사이즈를 줄이는 데 바이너리 파일에 포함된 디버그 정보와 <code>names</code> 섹션이 정말 큰 역할을 합니다. 하지만 <code>wasm-pack</code>이 기본값으로 디버그 정보를 삭제하고, 추가로 <code>wasm-opt</code>도 <code>-g</code>가 포함되지 않는 이상 <code>names</code> 섹션을 기본적으로 지우는 부분을 기억해주세요.</p>
<p>이 책을 잘 따라왔다면 기본적으로는 디버그 정보나 <code>names</code> 섹션 없이 wasm파일을 빌드하게 됩니다. 하지만, 이러한 디버깅 정보가 wasm 바이너리에 포함돼야 하는 상황에서는 이 내용을 잘 알아주세요!</p>
<h2 id="사이즈-프로파일링하기"><a class="header" href="#사이즈-프로파일링하기">사이즈 프로파일링하기</a></h2>
<p>빌드 최적화 설정을 바꿨는데도 <code>.wasm</code> 코드 사이즈가 줄어들지 않는다면, 어떤 부분이 나머지 공간을 사용하는지 프로파일링 작업을 해보면서 알아보도록 합시다.</p>
<blockquote>
<p>⚡ 타임 프로파일링 가이드를 따라왔던 것처럼, 사이즈 프로파일링 가이드도 한번 읽어보고 시도해봅시다. 읽어보는 것만으로도 시간을 정말 많이 아낄수 있습니다!</p>
</blockquote>
<h3 id="twiggy-코드-사이즈-프로파일러"><a class="header" href="#twiggy-코드-사이즈-프로파일러"><code>twiggy</code> 코드 사이즈 프로파일러</a></h3>
<p><a href="https://github.com/rustwasm/twiggy"><code>twiggy</code></a>는 WebAssembly를 입력으로 받는 코드 사이즈 프로파일러입니다. 바이너리의 <a href="https://en.wikipedia.org/wiki/Call_graph">call graph</a>를 분석하고 다음곽 같은 내용을 알려줍니다:</p>
<ul>
<li>
<p>함수들이 애초에 왜 바이너리에 포함되게 되는건가요?</p>
</li>
<li>
<p>이 함수에 <em>사용되는 공간의 사이즈</em>가 어떻게 되나요? 예: 이 함수를 포함해서 같이 사용하는 함수들 까지 삭제했을 때 얼마나 공간을 아낄수 있나요?</p>
</li>
</ul>
<style>
/* 알수 없는 이유로 mdbook의 기본 폰트가 box-drawing character와 호환이 되지 않아서 직접 스타일을 따로 생성했습니다. */
pre, code {
  font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
</style>
<pre><code class="language-text">$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────
          9158 ┊    19.65% ┊ "function names" subsection
          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8
          2510 ┊     5.39% ┊ &lt;str as core::fmt::Debug&gt;::fmt::he0d87479d1c208ea
          1737 ┊     3.73% ┊ data[0]
          1574 ┊     3.38% ┊ data[3]
          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5
          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d
          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced
          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b
          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605
           931 ┊     2.00% ┊ data[4]
           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05
           841 ┊     1.80% ┊ &lt;char as core::fmt::Debug&gt;::fmt::h07742d9f4a8c56f2
           813 ┊     1.74% ┊ __rust_realloc
           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85
           678 ┊     1.45% ┊ &lt;core::fmt::builders::PadAdapter&lt;'a&gt; as core::fmt::Write&gt;::write_str::h96b72fb7457d3062
           631 ┊     1.35% ┊ universe_tick
           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8
           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5
           503 ┊     1.08% ┊ &lt;&amp;'a T as core::fmt::Debug&gt;::fmt::hba207e4f7abaece6
</code></pre>
<h3 id="llvm-ir-직접-살펴보기"><a class="header" href="#llvm-ir-직접-살펴보기">LLVM-IR 직접 살펴보기</a></h3>
<p>LLMV-IR은 LLVM이 WebAssembly를 생성 하기 전에 받게 되는 최종 중간 표현 (final intermediate representation) 이기 때문에 최종적으로 출력되는 WebAssembly 바이너리와 매우 유사하게 생겼습니다. LLVM-IR의 사이즈가 클수록 출력되는 <code>.wasm</code> 파일의 사이즈도 커지게 되고, 함수들이 LLVM-IR 사이즈의 25%까지 차지하게 된다면 <code>.wasm</code> 파일에서도 함수들이 마찬가지로 25%를 차지하게 됩니다. 이러한 수치들이 보통은 일치하지만, LLVM-IR은 <code>.wasm</code> 파일이 (DWARF와 같은 디버깅 정보 처럼) 가지고 있지 않는 중요한 정보들을 가지고 있는 점도 참고해주세요. 이러한 하위 루틴들은 해당 함수의 위치에 인라인됩니다.</p>
<p><code>cargo</code> 명령어를 실행해서 LLVM-IR 파일을 생성해보세요:</p>
<pre><code>cargo rustc --release -- --emit llvm-ir
</code></pre>
<p>그 다음 <code>find</code> 명령어를 사용해서 <code>.ll</code> 파일을  찾아보겠습니다. 이 LLVM-IR 파일은 <code>cargo</code>의 <code>target</code> 디렉토리에 위치하게 됩니다:</p>
<pre><code>find target/release -type f -name '*.ll'
</code></pre>
<h4 id="레퍼런스"><a class="header" href="#레퍼런스">레퍼런스</a></h4>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM 언어 레퍼런스 메뉴얼</a></li>
</ul>
<h2 id="툴과-테크닉을-활용하여-더-깊게-파고들어서-최적화하기"><a class="header" href="#툴과-테크닉을-활용하여-더-깊게-파고들어서-최적화하기">툴과 테크닉을 활용하여 더 깊게 파고들어서 최적화하기</a></h2>
<p><code>.wasm</code> 바이너리 사이즈를 줄이는 설정은 보통 자동화가 돼 있습니다. 하지만 추가로 불필요한 코드를 제거하고 최적화를 해줘야 하는 경우에는 더 깊게 들어가서 수정해야 할 때가 있습니다. 이 섹션에서는 코드 사이즈를 줄일 때 사용해볼수 있는 투박한 방법들을 알아보겠습니다.</p>
<h3 id="문자열-포맷-피하기"><a class="header" href="#문자열-포맷-피하기">문자열 포맷 피하기</a></h3>
<p><code>format!</code>이나 <code>to_string</code> 과 같은 함수/매크로들을 사용하면 코드 사이즈가 불필요하게 커질수도 있습니다. 가능하면 문자열 포맷은 디버그 모드에서만 사용하고, 배포 모드에서는 정적 문자열 (static string) 을 사용해보세요.</p>
<h3 id="코드-패닉-피하기"><a class="header" href="#코드-패닉-피하기">코드 패닉 피하기</a></h3>
<p>말처럼 쉽지는 않지만, <code>twiggy</code> 와 같은 툴을 사용하거나 LLVM-IR 파일을 살펴보면서 어떤 함수들이 패닉하는지 살펴볼 수 있습니다.</p>
<p>패닉이 항상 <code>panic!()</code> 매크로의 형식으로 나타나지는 않고 다음과 같은 여러가지 이유로 발생할 수 있습니다:</p>
<ul>
<li>
<p>슬라이스 사이즈 범위를 벗어난 인덱스의 요소에 접근하고자 할 때 (out of bounds) : <code>my_slice[i]</code></p>
</li>
<li>
<p>나머지 연산자를 사용할 때 나누는 수가 0인 경우: <code>나눠지는 수 / 나누는 수</code></p>
</li>
<li>
<p><code>Option</code>이나 <code>Result</code>의 값을 <code>unwrap()</code>를 사용하여 접근할 때: <code>opt.unwrap()</code> 또는 <code>res.unwrap()</code></p>
</li>
</ul>
<p>처음 두 방법 대신 사용해볼수 있는 더 안전한 방법들도 있습니다. <code>my_slice[i]</code> 처럼 인덱스를 통해 직접 접근하지 않고 <code>my_slice.get(i)</code> 를 사용하여 <code>Option</code> 타입의 값에 접근해볼수도 있고, <code>check_div</code> 함수를 불러서 값을 나눌수 있는지 확인할수도 있습니다. 이렇게 3번쨰 경우만 집중할 수 있게 됩니다.</p>
<p>코드를 패닉시키지 않고, <code>Option</code>이나 <code>Result</code> 타입의 값을 "안전한 방법과 불안전한 방법", 두 가지 방법으로 처리해볼수도 있습니다.</p>
<p>안전한 방법부터 살펴보도록 합시다. <code>None</code>이나 <code>Error</code> 값이 나왔을 때, 코드를 패닉시키는 대신 <code>abort</code> 함수를 사용해보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub fn unwrap_abort&lt;T&gt;(o: Option&lt;T&gt;) -&gt; T {
    use std::process;
    match o {
        Some(t) =&gt; t,
        None =&gt; process::abort(),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>최종적으로는 패닉 코드가 <code>wasm32-unknown-unknown</code> 타겟의 abort 명령어로 옮겨지기 때문에, 이런 식으로 코드를 작성하면서 불필요한 코드를 지울 수 있습니다.</p>
<p>다른 방법으로는, <a href="https://crates.io/crates/unreachable"><code>unreachable</code> 크레이트</a>가 <code>Option</code>과 <code>Result</code> 타입의 값과 함께 사용할수 있도록 불안전한 <a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap"><code>unchecked_unwrap</code> 확장 크레이트</a>를 제공하는데, 이 확장 크레이트는 컴파일러가 <code>Option</code>을 <code>Some</code>으로, <code>Result</code>를 <code>Ok</code>로 <em>추측</em>해서 옮길수 있도록 도와줍니다. 하지만 이런 추측이 맞아떨어지지 않으면 정의하지 않은 동작 (undefined behavior) 이 발생하게 되므로, 코드가 잘 작동한다고 확신하지만 컴파일러가 모르는 상황에서 이 상황을 <em>잘 이해하고 있을 때만</em> 이 방법을 사용해주세요. 그리고 이 방법을 사용하더라도, 배포 버전에서만 적용하고 그 외에는 컴파일러가 확인할 수 있도록 디버그 빌드 설정하길 권장합니다.</p>
<h3 id="할당을-피하거나-wee_alloc을-대신-사용해보세요"><a class="header" href="#할당을-피하거나-wee_alloc을-대신-사용해보세요">할당을 피하거나 <code>wee_alloc</code>을 대신 사용해보세요.</a></h3>
<p>Rust는 기본값으로 <code>dlmalloc</code>라는 할당자를 이식해서 사용합니다. 이 할당자는 10 KB 정도의 사이즈를 차지하게 되는데, 동적 할당을 사용하지 않아도 괜찮다면 이 사이즈를 절약할 수 있습니다.</p>
<p>완전히 동적 할당 없이 작업하기가 쉽지는 않은 편인데, 코드의 <a href="https://en.wikipedia.org/wiki/Hot_spot_(computer_programming)">핫 스팟 (hot spot)</a> 에서 할당을 없애는 작업은 보통 훨씬 쉬운 편입니다. (보통은 이 작업을 통해 핫 스팟인 코드들을 훨씬 빠르게 만들수도 있습니다.) 이러한 상황에서 <a href="https://github.com/rustwasm/wee_alloc">전역 할당자 대신 <code>wee_alloc</code>를 사용하면</a> (전부는 아니지만) 이 10 KB의 공간의 대부분을 절약할 수 있습니다. <code>wee_alloc</code>는 할당자가 필요하지만 굳이 아주 빠를 필요가 없고, 실행 속도가 느려지는 대신 코드 사이즈를 줄여도 괜찮을 때 사용하도록 설계됐습니다.</p>
<h3 id="제네릭-타입-매개변수-대신-트레이트-객체를-사용해보세요"><a class="header" href="#제네릭-타입-매개변수-대신-트레이트-객체를-사용해보세요">제네릭 타입 매개변수 대신 트레이트 객체를 사용해보세요</a></h3>
<p>다음 예시와 같이 타입 매개변수를 사용하는 제네릭 함수를 작성한다고 생각해봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever&lt;T: MyTrait&gt;(t: T) { ... }
<span class="boring">}</span></code></pre></pre>
<p><code>rustc</code>와 LLVM는 제네릭 함수가 호출될 때 사용된 타입에 해당하는 바이너리 코드를 각각 따로 생성합니다. 이런 접근은 어떤 <code>T</code> 타입을 컴파일러가 처리하는지에 따라 컴파일러 최적화에 유용할 수 있습니다. 하지만 동시에 코드 사이즈가 빠르게 늘어날 수도 있다는 단점을 가지고 있습니다.</p>
<p>다음과 같이 타입 매개변수 대신 트레이트 객체를 사용해보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever(t: Box&lt;MyTrait&gt;) { ... }
// or
fn whatever(t: &amp;MyTrait) { ... }
// etc...
<span class="boring">}</span></code></pre></pre>
<p>이 코드를 컴파일할 때 가상 환경에서 함수들을 동적 디스패치 (dynamic dispatch) 라는 메커니즘으로 처리하게 되는데, 한 가지 버전의 함수만 <code>.wasm</code> 파일로 처리되게 됩니다. 이러한 처리를 하면서 컴파일러 최적화 측면에서 손실이 있을 수 있고, 간접적이고 동적으로 디스패치된 함수를 부르는데 추가적인 비용이 들수도 있다는 단점이 있습니다.</p>
<h3 id="wasm-snip-툴을-사용해보세요"><a class="header" href="#wasm-snip-툴을-사용해보세요"><code>wasm-snip</code> 툴을 사용해보세요</a></h3>
<p><a href="https://github.com/fitzgen/wasm-snip"><code>wasm-snip</code>은 WebAssembly 함수의 코드를 <code>unreachable</code> Assembly 명령어로 교체해줍니다.</a> 하지만 잘 살펴보면 못 하나를 박는다고 아주 거대한 망치를 가져와서 열심히 두드리는 것 같은 느낌이 듭니다.</p>
<p>런타임에서 사용하지 않는 함수들이 간접적으로 호출하는 다른 함수들을 어떻게 컴파일러에게 제거하라고 시켜야 할까요? 우선은 코드를 빌드 해보고 <code>wasm-opt</code>를 <code>--dce</code> 플래그를 포함해서 다시 실행해보세요! 간접적으로 호출되는 (런타임에서 부르지 않는) 함수들까지 지워버릴 수 있습니다.</p>
<p>패닉 코드가 이런 문제들로 종종 이어질 수 있기 때문에, 패닉 인프라 (panicking infrastructure) 를 지울 때 이 툴이 유용하게 사용될 수 있습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/time-profiling.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/js-ffi.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/time-profiling.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/js-ffi.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
