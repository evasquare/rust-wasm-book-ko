<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust and WebAssembly</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 소개</a></li><li class="chapter-item expanded "><a href="why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> 왜 Rust로 WebAssembly 개발을 해야 하나요?</a></li><li class="chapter-item expanded "><a href="background-and-concepts.html"><strong aria-hidden="true">3.</strong> 배경지식</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> WebAssembly가 뭔가요?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> 튜토리얼</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> 셋업</a></li><li class="chapter-item expanded "><a href="game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> 규칙</a></li><li class="chapter-item expanded "><a href="game-of-life/implementing.html"><strong aria-hidden="true">4.4.</strong> Game of Life 구현하기</a></li><li class="chapter-item expanded "><a href="game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> Game of Life 테스팅하기</a></li><li class="chapter-item expanded "><a href="game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> 디버깅</a></li><li class="chapter-item expanded "><a href="game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> 상호작용 추가하기</a></li><li class="chapter-item expanded "><a href="game-of-life/time-profiling.html"><strong aria-hidden="true">4.8.</strong> 타임 프로파일링</a></li><li class="chapter-item expanded "><a href="game-of-life/code-size.html"><strong aria-hidden="true">4.9.</strong> .wasm 파일 사이즈 줄이기</a></li><li class="chapter-item expanded "><a href="game-of-life/publishing-to-npm.html"><strong aria-hidden="true">4.10.</strong> npm에 배포하기</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">5.</strong> 참조</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/crates.html"><strong aria-hidden="true">5.1.</strong> 알면 좋은 크레이트들</a></li><li class="chapter-item expanded "><a href="reference/tools.html"><strong aria-hidden="true">5.2.</strong> 알면 좋은 툴들</a></li><li class="chapter-item expanded "><a href="reference/project-templates.html"><strong aria-hidden="true">5.3.</strong> 프로젝트 템플릿</a></li><li class="chapter-item expanded "><a href="reference/debugging.html"><strong aria-hidden="true">5.4.</strong> 디버깅</a></li><li class="chapter-item expanded "><a href="reference/time-profiling.html"><strong aria-hidden="true">5.5.</strong> 타임 프로파일링</a></li><li class="chapter-item expanded "><a href="reference/code-size.html"><strong aria-hidden="true">5.6.</strong> .wasm 파일 사이즈 줄이기</a></li><li class="chapter-item expanded "><a href="reference/js-ffi.html"><strong aria-hidden="true">5.7.</strong> JavaScript 상호 운용하기</a></li><li class="chapter-item expanded "><a href="reference/which-crates-work-with-wasm.html"><strong aria-hidden="true">5.8.</strong> 어떤 Rust 크레이트들을 WebAssembly에서 바로 사용할 수 있나요?</a></li><li class="chapter-item expanded "><a href="reference/add-wasm-support-to-crate.html"><strong aria-hidden="true">5.9.</strong> 다목적 크레이트가 WebAssembly를 지원하도록 코드 수정하기</a></li><li class="chapter-item expanded "><a href="reference/deploying-to-production.html"><strong aria-hidden="true">5.10.</strong> Rust와 WebAssembly 코드를 실제 환경에 배포하기</a></li><li class="chapter-item expanded "><a href="reference/translations.html"><strong aria-hidden="true">5.11.</strong> 번역본</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust--and-webassembly-"><a class="header" href="#rust--and-webassembly-">Rust 🦀 and WebAssembly 🕸</a></h1>
<p>이 간결한 책은 <a href="https://www.rust-lang.org">Rust</a>와 <a href="https://webassembly.org/">WebAssembly</a>를 함께 사용하는 방법을 다룹니다.</p>
<blockquote>
<p>번역된 버전에 이슈나 풀 리퀘스트를 생성하고자 하시나요? <a href="https://github.com/pixelbracket/rust-wasm-book-ko">번역 버전의 레포지토리</a>를 확인해 주세요.</p>
</blockquote>
<h2 id="누구를-위한-책인가요"><a class="header" href="#누구를-위한-책인가요">누구를 위한 책인가요?</a></h2>
<p>이 책은 Rust와 WebAssembly를 함께 사용하여 웹에서 동작하는 빠르고 안정된 코드를 작성하는 방법에 대해 관심이 있는 분들을 위해 작성되었습니다.
꼭 전문가가 돼야할 필요는 없지만, Rust를 조금이라도 알아야 하고 JavaScript와 HTML, CSS에 익숙하면 더 좋습니다.</p>
<p>Rust를 아직 모르시나요? <a href="https://doc.rust-lang.org/book/"><em>The Rust Programming Language</em> 책으로 시작해 보세요.</a></p>
<p>JavaScript나 HTML, CSS를 모르시나요? <a href="https://developer.mozilla.org/en-US/docs/Learn">MDN에서 더 알아보세요.</a></p>
<h2 id="이-책을-읽는-방법"><a class="header" href="#이-책을-읽는-방법">이 책을 읽는 방법</a></h2>
<p><a href="./why-rust-and-webassembly.html">왜 Rust로 WebAssembly 개발을 해야 하나요?</a> 섹션을 읽어보면 좋고, <a href="./background-and-concepts.html">배경지식</a>과 먼저 친숙해져 보는 것도 좋습니다.</p>
<p>이 <a href="./game-of-life/introduction.html">튜토리얼</a>은 처음부터 끝까지 읽도록 작성됐습니다. 튜토리얼에 있는 코드를 작성, 컴파일하고 직접 실행해 보세요. Rust와 WebAssembly를 같이 사용해 본 적이 없다면, 튜토리얼을 한번 활용해 보세요!</p>
<p><a href="./reference/index.html">참조 섹션</a> 은 아무 순서로 정독해도 괜찮습니다.</p>
<blockquote>
<p><strong>💡 팁:</strong> 페이지 최상단에 있는 🔍 아이콘을 누르거나 <code>s</code> 키를 눌러서 책 전체를 검색해 볼 수도 있습니다.</p>
</blockquote>
<h2 id="번역본"><a class="header" href="#번역본">번역본</a></h2>
<p>커뮤니티 <a href="./reference/translations.html">번역본</a>도 있으니 한번 확인해 보세요.</p>
<h2 id="이-책에-기여하기"><a class="header" href="#이-책에-기여하기">이 책에 기여하기</a></h2>
<p>이 책은 오픈소스입니다! 오타를 찾으셨나요? 누락된 부분이 있나요? <a href="https://github.com/rustwasm/book"><strong>풀 리퀘스트를 생성해 보세요!</strong></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="왜-rust로-webassembly-개발을-해야-하나요"><a class="header" href="#왜-rust로-webassembly-개발을-해야-하나요">왜 Rust로 WebAssembly 개발을 해야 하나요?</a></h1>
<h2 id="저레벨-컨트롤과-고레벨-개발자-경험"><a class="header" href="#저레벨-컨트롤과-고레벨-개발자-경험">저레벨 컨트롤과 고레벨 개발자 경험</a></h2>
<p>JavaScript 웹 앱들은 안정된 성능을 확보하고 유지하는 데 어려움을 겪습니다. JavaScript 동적 타입 시스템과 가비지 콜렉션 (Garbage Collection) 을 잠시 중단하는 것만으로는 크게 도움이 되지 않습니다. 보기에는 작은 내용의 코드를 수정하더라도 JIT에 치명적인 코드를 작성한다면 드라마틱한 성능 저하를 일으킬 수도 있습니다.</p>
<p>Rust는 JavaScript를 병들게 만드는 비결정적인 가비지 콜렉션 중단으로부터 자유로울 뿐 아니라, 프로그래머들이 간접지정(indirection)과 단일화(monomorphization), 메모리 레이아웃을 컨트롤할 수 있도록 함으로 저레벨 컨트롤과 안정된 성능을 제공합니다.</p>
<h2 id="작은-wasm-사이즈"><a class="header" href="#작은-wasm-사이즈">작은 <code>.wasm</code> 사이즈</a></h2>
<p><code>.wasm</code> 파일이 네트워크로 전송돼야 하는 점을 고려하면 코드의 파일 사이즈는 매우 중요합니다. Rust는 런타임이 작고 가비지 콜렉터와 같은 불필요한 요소가 없어 <code>.wasm</code> 사이즈를 효과적으로 줄일 수 있도록 해주고, 실제로 사용하지 않는 함수들을 (빌드하는 코드 파일에서) 제외시켜줍니다.</p>
<p>이렇게 코드 파일 사이즈의 관점에서 실제로 사용하는 기능만 출력되는 코드에 포함할 수 있게 됩니다.</p>
<h2 id="모든-내용을-다시-작성하지-말아-주세요"><a class="header" href="#모든-내용을-다시-작성하지-말아-주세요">모든 내용을 다시 작성하지 <strong>말아 주세요</strong></a></h2>
<p>기존에 존재하는 코드 베이스를 지울 필요는 없습니다. 바로 효과를 볼 수 있도록 성능 개선이 중요한 JavaScript 함수들을 먼저 Rust로 옮기는 것으로 시작해 볼 수도 있습니다. 원한다면 거기서 멈춰도 괜찮습니다.</p>
<h2 id="다른-툴과-잘-작동합니다"><a class="header" href="#다른-툴과-잘-작동합니다">다른 툴과 잘 작동합니다</a></h2>
<p>Rust와 WebAssembly는 기존에 존재하는 JavaScript 툴들과 함께 가장 잘 작동합니다. WebAssembly는 ECMAScript 모듈을 지원하고, 개발 환경에서 npm과 Webpack처럼 기존에 사랑받던 툴들을 계속 사용할 수도 있습니다.</p>
<h2 id="기대할-수-있는-강점들"><a class="header" href="#기대할-수-있는-강점들">기대할 수 있는 강점들</a></h2>
<p>Rust는 다음과 같이 개발자들이 일반적으로 기대하게 되는 현대적인 편의 기능을 갖추고 있습니다.</p>
<ul>
<li>
<p><code>cargo</code>로 강력한 패키지 관리하기</p>
</li>
<li>
<p>(추가 비용 없이) 이해하기 쉬운 코드를 쓸 수 있게 해주는 추상화</p>
</li>
<li>
<p>환영하는 커뮤니티! 😊</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="배경지식"><a class="header" href="#배경지식">배경지식</a></h1>
<p>이 섹션은 Rust와 WebAssembly 개발을 시작할 때 필요한 배경지식을 설명해줍니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly가-뭔가요"><a class="header" href="#webassembly가-뭔가요">WebAssembly가 뭔가요?</a></h1>
<p>WebAssembly(wasm)는 <a href="https://webassembly.github.io/spec/">포괄적인 사양</a>을 가지고 있는 간단한 기계 모델이자 실행 가능한 포맷입니다. 휴대 가능하고, 가벼우며 거의 네이티브 프로그램과 같은 속도로 실행될 수 있도록 설계됐습니다.</p>
<p>프로그래밍 언어로써, WebAssembly는 같은 구조를 나타내는데, 두 가지 다른 포맷으로 구성돼 있습니다.</p>
<ol>
<li>
<p>("<strong>W</strong>eb<strong>A</strong>ssembly <strong>T</strong>ext" 에서 이름이 유래된) <code>.wat</code> 텍스트 포맷은 <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a> 구조를 사용하고 Scheme이나 Clojure와 같은 Lisp 계열 언어와 유사점들을 공유합니다.</p>
</li>
<li>
<p><code>.wasm</code> 바이너리 포맷은 더 저레벨이면서 WebAssembly 가상 머신에서 바로 사용되도록 의도됐습니다. 개념적으로 ELF 와 Mach-0와 비슷합니다.</p>
</li>
</ol>
<p>참고 자료로, <code>wat</code> 언어로 작성된 팩토리얼 함수를 확인해 보세요.</p>
<pre><code>(module
  (func $fac (param f64) (result f64)
    local.get 0
    f64.const 1
    f64.lt
    if (result f64)
      f64.const 1
    else
      local.get 0
      local.get 0
      f64.const 1
      f64.sub
      call $fac
      f64.mul
    end)
  (export "fac" (func $fac)))
</code></pre>
<p>위 예제가 <code>.wasm</code> 파일로는 어떻게 보일지 궁금하다면, <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm 데모</a> 웹사이트를 이용해 보세요.</p>
<h2 id="선형-메모리-linear-memory"><a class="header" href="#선형-메모리-linear-memory">선형 메모리 (Linear Memory)</a></h2>
<p>WebAssembly 매우 간단한 <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem">메모리 모델</a>을 가지고 있고, 한 wasm 모듈은 하나의 "선형 메모리" 에 접근할 수 있습니다.</p>
<p>이 메모리는 페이지 사이즈 (64K)의 곱만큼 <a href="https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-memory">커질 수 있으며</a> 이 사이즈는 줄어들 수 없습니다.</p>
<h2 id="웹에서만-webassembly를-사용할-수-있나요"><a class="header" href="#웹에서만-webassembly를-사용할-수-있나요">웹에서만 WebAssembly를 사용할 수 있나요?</a></h2>
<p>현재로는 JavaScript 웹 커뮤니티에서 주로 주목을 받고 있지만, wasm은 특정 실행 환경을 필요로 하지 않습니다. 그러므로, wasm이 미래에 다양한 맥락에서 사용할 수 있는 "휴대 가능한 실행할 수 있는" 포맷이라고 여겨질수도 있습니다. 하지만 오늘날 현재 시점에서는 wasm은 (웹과 <a href="https://nodejs.org">Node.js</a>을 포함한) 다양한 형태로 존재하는 JavaScript (JS)와 함께 주로 언급됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="튜토리얼-conways-game-of-life"><a class="header" href="#튜토리얼-conways-game-of-life">튜토리얼: Conway's Game of Life</a></h1>
<p>이 튜토리얼은 <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway's Game of Life</a>를 Rust와 WebAssembly로 구현하는 내용을 다룹니다.</p>
<h2 id="누구를-위한-튜토리얼인가요"><a class="header" href="#누구를-위한-튜토리얼인가요">누구를 위한 튜토리얼인가요?</a></h2>
<p>이 튜토리얼은 이미 기초적인 Rust와 JavaScript를 배웠고, Rust와 WebAssembly, JavaScript를 같이 사용하고 싶어 하는 사람들을 위해 작성됐습니다.</p>
<p>원활한 진행을 위해 기초적인 Rust, JavaScript, HTML 코드를 문제없이 작성할 수 있어야 합니다. 하지만 전문가가 돼야 할 필요는 전혀 없습니다.</p>
<h2 id="무엇을-배우게-되나요"><a class="header" href="#무엇을-배우게-되나요">무엇을 배우게 되나요?</a></h2>
<ul>
<li>
<p>WebAssembly를 컴파일할 수 있도록 Rust 툴체인을 설정하는 법.</p>
</li>
<li>
<p>Rust, WebAssembly, JavaScript, HTML, CSS으로 다언어 프로그램을 개발할 수 있는 워크플로우.</p>
</li>
<li>
<p>Rust와 WebAssembly, 그리고 JavaScript의 강점을 모두 살리도록 API를 설계하는 방법.</p>
</li>
<li>
<p>Rust 코드에서 컴파일된 WebAssembly 모듈을 디버깅하는 방법.</p>
</li>
<li>
<p>Rust와 WebAssembly 프로그램을 더 빠르게 만들기 위해 타임 프로파일링하는 방법.</p>
</li>
<li>
<p><code>.wasm</code> 바이너리를 더 작고 빠르게 만들어 네트워크를 통한 다운로드가 더 원활할 수 있도록 Rust와 WebAssembly 프로그램을 사이즈 프로파일링하는 방법.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="셋업"><a class="header" href="#셋업">셋업</a></h1>
<p>이 섹션에서는 Rust 프로그램들을 WebAssembly로 컴파일하고 JavaScript 환경과 통합시키는 방법에 대해 다루어 보겠습니다.</p>
<h2 id="rust-툴체인"><a class="header" href="#rust-툴체인">Rust 툴체인</a></h2>
<p>진행을 위해 <code>rustup</code>, <code>rustc</code>, <code>cargo</code>를 포함한 스탠다드 Rust 툴체인이 필요합니다.</p>
<p><a href="https://www.rust-lang.org/tools/install">Rust 툴체인을 설치하려면 이 지침을 따라주세요.</a></p>
<p>Rust와 WebAssembly 개발 경험이 stable 버전의 Rust에 포함될 만큼 안정화되고 있기 때문에 어떤 실험적 기능 flag도 요구되지 않습니다. 하지만 Rust 1.30이나 그 이후 버전이 요구됩니다.</p>
<h2 id="wasm-pack"><a class="header" href="#wasm-pack"><code>wasm-pack</code></a></h2>
<p><code>wasm-pack</code>은 Rust로 생성한 WebAssembly를 개발, 테스팅, 배포하도록 도와주는 만능 툴입니다.</p>
<p><a href="https://rustwasm.github.io/wasm-pack/installer/">여기서 <code>wasm-pack</code> 다운로드 해보세요!</a></p>
<h2 id="cargo-generate"><a class="header" href="#cargo-generate"><code>cargo-generate</code></a></h2>
<p><a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code>를 통해 기존에 존재하는 git 레포지토리를 템플릿으로 사용하면서 새 Rust 프로젝트를 시작하고 빠르게 실행할 수 있습니다.</a></p>
<p>이 명령어로 <code>cargo-generate</code>를 설치해 보세요:</p>
<pre><code>cargo install cargo-generate
</code></pre>
<h2 id="npm"><a class="header" href="#npm"><code>npm</code></a></h2>
<p><code>npm</code>은 JavaScript와 함께 사용되는 패키지 매니저입니다. 이 책을 진행하면서 JavaScript 번들러와 개발 서버를 설치하고 구동하는 데 사용될 예정입니다. 이 튜토리얼 끝에서는 컴파일된 <code>.wasm</code>을 <code>npm</code> 레지스트리에 배포해 봅니다.</p>
<p><a href="https://www.npmjs.com/get-npm"><code>npm</code> 을 설치하려면 이 지침을 따라주세요.</a></p>
<p>이미 <code>npm</code>이 설치돼 있다면, 이 명령어를 통해 최신 버전으로 업데이트돼 있는지 확인해 주세요:</p>
<pre><code>npm install npm@latest -g
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>이 섹션에서는 Rust와 WebAssembly 프로그램을 처음 실행하는 과정을 다룹니다. "Hello, World!" 메세지를 보여주는 웹페이지를 만들어봅시다.</p>
<p>시작하기 전에 <a href="game-of-life/setup.html">셋업 가이드</a>를 읽고 잘 따라왔는지 한 번 더 확인해 주세요.</p>
<h2 id="프로젝트-템플릿-클론하기"><a class="header" href="#프로젝트-템플릿-클론하기">프로젝트 템플릿 클론하기</a></h2>
<p>이 프로젝트 템플릿은 합리적인 기본 설정으로 구성돼 있습니다. 이 템플릿을 활용해서 웹으로 코드를 빠르게 개발, 통합 및 패키징할 수 있습니다.</p>
<p>이 명령어로 프로젝트를 클론해보세요:</p>
<pre><code class="language-text">cargo generate --git https://github.com/rustwasm/wasm-pack-template
</code></pre>
<p>새 프로젝트 이름을 어떻게 지을지 입력하게 됩니다. <strong>"wasm-game-of-life"</strong> 이라는 이름을 사용합시다.</p>
<pre><code class="language-text">wasm-game-of-life
</code></pre>
<h2 id="어떻게-구성돼-있나요"><a class="header" href="#어떻게-구성돼-있나요">어떻게 구성돼 있나요?</a></h2>
<p>새로 생성한 <code>wasm-game-of-life</code> 프로젝트를 열어보도록 합시다.</p>
<pre><code>cd wasm-game-of-life
</code></pre>
<p>그다음 안에 어떤 파일이 담겨있는지 확인해 봅시다:</p>
<pre><code class="language-text">wasm-game-of-life/
├── Cargo.toml
├── LICENSE_APACHE
├── LICENSE_MIT
├── README.md
└── src
    ├── lib.rs
    └── utils.rs
</code></pre>
<p>몇 가지 파일을 더 자세히 살펴볼까요?</p>
<h3 id="wasm-game-of-lifecargotoml"><a class="header" href="#wasm-game-of-lifecargotoml"><code>wasm-game-of-life/Cargo.toml</code></a></h3>
<p><code>Cargo.toml</code> 파일은 Rust의 패키지 매니저이자 빌드 툴인 <code>cargo</code>와 함께 사용되는데, 의존성과 메타데이터를 지정하는 역할을 합니다. 이 파일은 <code>wasm-bindgen</code> 의존성과 함께 <code>wasm</code> 라이브러리 생성에 사용될 수 있도록 올바르게 설정된 <code>crate-type</code>이 함께 사전에 미리 포함돼 있습니다. 몇 가지 필수가 아닌 의존성은 나중에 살펴보겠습니다.</p>
<h3 id="wasm-game-of-lifesrclibrs"><a class="header" href="#wasm-game-of-lifesrclibrs"><code>wasm-game-of-life/src/lib.rs</code></a></h3>
<p><code>src/lib.rs</code> 파일은 WebAssembly로 컴파일하는 Rust 크레이트의 핵심 코드입니다. <code>wasm-bindgen</code>을 JavaScript를 조작하기 위해 사용하고, <code>window.alert</code> JavaScript 함수를 불러온 다음에 <code>greet</code> Rust 함수를 JavaScript로 보냅니다. 이렇게 "Hello World" alert 메세지를 표시시킬 수 있게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod utils;

use wasm_bindgen::prelude::*;

// `wee_alloc` 기능이 활성화돼 있으면, `wee-alloc`를 전역 할당자로 사용합니다.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet() {
    alert("Hello, wasm-game-of-life!");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="wasm-game-of-lifesrcutilsrs"><a class="header" href="#wasm-game-of-lifesrcutilsrs"><code>wasm-game-of-life/src/utils.rs</code></a></h3>
<p><code>src/utils.rs</code> 모듈은 자주 사용되는 유틸리티를 제공하는데, 이 유틸리티가 WebAssembly로 컴파일된 Rust 코드 작업을 더 쉽게 할 수 있도록 도와줍니다. <a href="game-of-life/debugging.html">wasm 코드 디버깅하기</a>와 같은 튜토리얼 후반 섹션에서 이러한 유틸리티들을 더 자세히 살펴보겠습니다. 현재 시점에서는 이 파일을 무시해도 괜찮습니다.</p>
<h2 id="프로젝트-빌드하기"><a class="header" href="#프로젝트-빌드하기">프로젝트 빌드하기</a></h2>
<p><code>wasm-pack</code>을 사용하여 다음 빌드 과정을 자동화하게 됩니다:</p>
<ul>
<li>Rust 1.30나 그 이후 버전을 사용하고 있는지, <code>wasm32-unknown-unknown</code> 타겟이 <code>rustup</code>을 통해 설치돼 있는지 확인합니다.</li>
<li><code>cargo</code>를 사용하여 Rust 소스 코드를 WebAssembly <code>.wasm</code> 바이너리로 컴파일합니다.</li>
<li><code>wasm-bindgen</code>을 사용하여 Rust로 생성한 WebAssembly를 사용할 수 있도록 JavaScript API를 생성합니다.</li>
</ul>
<p>위 작업을 시작하려면, 프로젝트 경로에서 다음 명령어를 실행해 주세요:</p>
<pre><code>wasm-pack build
</code></pre>
<p>빌드가 완료되면 결과물을 <code>pkg</code> 경로에서 확인해 보세요. 다음 내용물을 확인할 수 있습니다:</p>
<pre><code>pkg/
├── package.json
├── README.md
├── wasm_game_of_life_bg.wasm
├── wasm_game_of_life.d.ts
└── wasm_game_of_life.js
</code></pre>
<p><code>README.md</code> 파일이 메인 프로젝트에서 복사됐지만 나머지 파일들은 완전히 새로 생성된 부분을 확인할 수 있습니다.</p>
<h3 id="wasm-game-of-lifepkgwasm_game_of_life_bgwasm"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_life_bgwasm"><code>wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm</code></a></h3>
<p>이러한 <code>.wasm</code> 파일은 Rust 컴파일러가 Rust 소스 코드로 생성한 바이너리 파일입니다. 이 파일은 wasm 형식으로 컴파일된 모든 Rust 함수들과 데이터로 구성돼 있습니다. 변환된 "greet" 함수가 예가 될 수 있습니다.</p>
<h3 id="wasm-game-of-lifepkgwasm_game_of_lifejs"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_lifejs"><code>wasm-game-of-life/pkg/wasm_game_of_life.js</code></a></h3>
<p>이러한 <code>.js</code> 파일은 <code>wasm-bindgen</code>에 의해 생성됩니다. DOM과 JavaScript 함수를 Rust에서 호출할 수 있게 해주고, JavaScript 환경에서도 WebAssembly 함수를 호출할 수 있도록 도와주는 유용한 API를 노출시켜줍니다. 예를 들어서, <code>greet</code> 이라는 JavaScript 함수를 통해 WebAssembly의 해당하는 함수를 호출할 수 있습니다. 현재 시점에서는 이러한 바인딩(bindings glue)들이 큰 역할을 하지는 않지만, 더 복잡한 값들을 wasm과 JavaScript 사이에서 주고받을 때 정말 도움이 많이 됩니다.</p>
<pre><code class="language-js">import * as wasm from './wasm_game_of_life_bg';

// ...

export function greet() {
    return wasm.greet();
}
</code></pre>
<h3 id="wasm-game-of-lifepkgwasm_game_of_lifedts"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_lifedts"><code>wasm-game-of-life/pkg/wasm_game_of_life.d.ts</code></a></h3>
<p><code>.d.ts</code> 파일은 생성한 JavaScript 파일과 함께 사용할 수 있는 <a href="http://www.typescriptlang.org/">TypeScript</a> 타입 정의를 포함합니다. TypeScript를 사용한다면 정적 타입 정의를 통해 IDE가 제공하는 자동 완성과 같은 기능을 사용해서 더 쉽게 WebAssembly 함수를 호출할 수 있게 됩니다. TypeScript를 사용하지 않는다면, 이 파일은 무시해도 괜찮습니다.</p>
<pre><code class="language-typescript">export function greet(): void;
</code></pre>
<h3 id="wasm-game-of-lifepkgpackagejson"><a class="header" href="#wasm-game-of-lifepkgpackagejson"><code>wasm-game-of-life/pkg/package.json</code></a></h3>
<p><a href="https://docs.npmjs.com/files/package.json"><code>package.json</code> 파일은 생성된 JavaScript와 WebAssembly 패키지에 대한 메타데이터를 포함합니다.</a> 이런 메타데이터는 npm과 JavaScript 번들러가 여러 패키지들의 종속성, 패키지 이름, 버전 등을 결정할 때 사용됩니다. JavaScript 툴링과 함께 사용하고 npm에 WebAssembly 패키지를 배포할 때 유용합니다.</p>
<pre><code class="language-json">{
  "name": "wasm-game-of-life",
  "collaborators": [
    "Your Name &lt;your.email@example.com&gt;"
  ],
  "description": null,
  "version": "0.1.0",
  "license": null,
  "repository": null,
  "files": [
    "wasm_game_of_life_bg.wasm",
    "wasm_game_of_life.d.ts"
  ],
  "main": "wasm_game_of_life.js",
  "types": "wasm_game_of_life.d.ts"
}
</code></pre>
<h2 id="웹-페이지에-포함시키기"><a class="header" href="#웹-페이지에-포함시키기">웹 페이지에 포함시키기</a></h2>
<p><code>wasm-game-of-life</code> 패키지를 웹페이지에 포함시키고 웹 환경에서 작동시키기 위해, <a href="https://github.com/rustwasm/create-wasm-app">
<code>create-wasm-app</code> JavaScript 프로젝트 템플릿</a> 을 사용해 봅시다.</p>
<p>다음 명령어를 <code>wasm-game-of-life</code> 경로 내부에서 실행해 주세요:</p>
<pre><code>npm init wasm-app www
</code></pre>
<p>새롭게 생성된 내부 경로인 <code>wasm-game-of-life/www</code> 는 다음 파일들을 포함합니다:</p>
<pre><code>wasm-game-of-life/www/
├── bootstrap.js
├── index.html
├── index.js
├── LICENSE-APACHE
├── LICENSE-MIT
├── package.json
├── README.md
└── webpack.config.js
</code></pre>
<p>한 번 더 생성된 파일들을 자세히 살펴봅시다.</p>
<h3 id="wasm-game-of-lifewwwpackagejson"><a class="header" href="#wasm-game-of-lifewwwpackagejson"><code>wasm-game-of-life/www/package.json</code></a></h3>
<p>이 <code>package.json</code> 파일은 <code>webpack</code>과 <code>webpack-dev-server</code> 종속성들로 미리 셋업이 되어 있고, npm 에 배포돼 있는 <code>wasm-pack-template</code>의 초기 버전인 <code>hello-wasm-pack</code> 패키지 또한 종속성으로 포함하고 있습니다.</p>
<h3 id="wasm-game-of-lifewwwwebpackconfigjs"><a class="header" href="#wasm-game-of-lifewwwwebpackconfigjs"><code>wasm-game-of-life/www/webpack.config.js</code></a></h3>
<p>이 파일은 webpack과 로컬 개발 서버를 설정합니다. 미리 셋업 작업이 돼 있는데, webpack과 로컬 개발 서버를 사용할 때에도 전혀 따로 수정할 필요가 없습니다.</p>
<h3 id="wasm-game-of-lifewwwindexhtml"><a class="header" href="#wasm-game-of-lifewwwindexhtml"><code>wasm-game-of-life/www/index.html</code></a></h3>
<p>웹사이트에 사용되는 최상단 HTML 파일입니다. <code>index.js</code> 를 감싸주는 <code>bootstrap.js</code>를 부르는 것 외에는 특별한 동작을 하지 않습니다.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello wasm-pack!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="./bootstrap.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="wasm-game-of-lifewwwindexjs"><a class="header" href="#wasm-game-of-lifewwwindexjs"><code>wasm-game-of-life/www/index.js</code></a></h3>
<p>이 <code>index.js</code>는 작업을 하게 될 웹사이트 JavaScript의 진입점 (entry point) 입니다. JavaScript 코드와 <code>wasm-pack-template</code>의 컴파일 결과물인 WebAssembly가 포함돼 있는데, <code>hello-wasm-pack</code> npm 패키지를 로드하고 패키지 내부의 <code>greet</code> 함수를 호출해 줍니다.</p>
<pre><code class="language-js">import * as wasm from "hello-wasm-pack";

wasm.greet();
</code></pre>
<h3 id="종속성-설치하기"><a class="header" href="#종속성-설치하기">종속성 설치하기</a></h3>
<p>우선, <code>wasm-game-of-life/www</code> 내부 경로에서 <code>npm install</code> 명령어를 실행하여 로컬 개발 서버와 종속성들이 설치돼 있는지 확인해 주세요:</p>
<pre><code class="language-text">npm install
</code></pre>
<p>이 커맨드는 한 번만 실행돼야 합니다. 실행하면 <code>webpack</code> JavaScript 번들러와 개발 서버를 설치할 수 있습니다.</p>
<blockquote>
<p>단순히 간편하게 책을 진행하기 위해 이 번들러와 개발 서버를 사용할 예정이지만
<code>webpack</code>이 Rust와 WebAssembly 작업에 필수가 아니라는 점을 기억해 주세요.
Parcel과 Rollup도 WebAssembly와 ECMAScript 모듈을 부르는 데 사용할 수 있습니다.
원한다면 Rust와 WebAssembly를 <a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html">번들러 없이</a> 사용할 수도 있습니다.</p>
</blockquote>
<h3 id="www-패키지-내부에서-로컬-wasm-game-of-life-패키지-사용하기"><a class="header" href="#www-패키지-내부에서-로컬-wasm-game-of-life-패키지-사용하기"><code>www</code> 패키지 내부에서 로컬 <code>wasm-game-of-life</code> 패키지 사용하기</a></h3>
<p>npm에서 다운로드한 <code>hello-wasm-pack</code> 대신에 로컬 환경에 있는 <code>wasm-game-of-life</code>를 사용해 봅시다. 이렇게 함으로써 Game of Life 프로그램을 더 점진적으로 개발할 수 있게 됩니다.</p>
<p><code>wasm-game-of-life/www/package.json</code> 파일을 열고 <code>devDependencies</code> 다음에 <code>dependencies</code> 필드를 생성해 주세요. 그다음에, <code>"wasm-game-of-life": "file:../pkg"</code> 엔트리를 포함시켜주세요.</p>
<pre><code class="language-js">{
  // ...
  "dependencies": {                     // 이 3줄 길이의 블럭을 추가해주세요!
    "wasm-game-of-life": "file:../pkg"
  },
  "devDependencies": {
    //...
  }
}
</code></pre>
<p>다음으로, <code>hello-wasm-pack</code> 대신에 <code>wasm-game-of-life</code>를 부를 수 있도록 <code>wasm-game-of-life/www/index.js</code> 파일을 수정해 주세요:</p>
<pre><code class="language-js">import * as wasm from "wasm-game-of-life";

wasm.greet();
</code></pre>
<p>새 종속성을 만들었다면, 다음 명령어로 설치해야 합니다:</p>
<pre><code class="language-text">npm install
</code></pre>
<p>이제 웹사이트를 로컬 환경에서 구동할 수 있게 됐습니다!</p>
<h2 id="로컬-환경에서-구동하기"><a class="header" href="#로컬-환경에서-구동하기">로컬 환경에서 구동하기</a></h2>
<p>이제 개발 서버를 구동할 새 터미널을 열어주세요. 새로 연 터미널에서 서버를 구동하면 백그라운드에서 계속 서버를 구동하면서 다른 명령어를 계속 입력할 수 있게 됩니다. 새 터미널에서 <code>wasm-game-of-life/www</code> 경로로 들어간 다음 이 명령어를 실행해 주세요:</p>
<pre><code>npm run start
</code></pre>
<p>웹 브라우저를 열고 <a href="http://localhost:8080/">http://localhost:8080/</a> 를 열면 표시되는 "Hello World" alert 메세지를 확인할 수 있습니다:</p>
<p><a href="game-of-life/../images/game-of-life/hello-world.png"><img src="game-of-life/../images/game-of-life/hello-world.png" alt="&quot;Hello, wasm-game-of-life!&quot; 웹 페이지 alert 메세지 스크린샷" /></a></p>
<p>파일을 저장할 때마다 <a href="http://localhost:8080/">http://localhost:8080/</a> 페이지에 반영되도록 하고 싶다면, <code>wasm-pack build</code> 명령어를 <code>wasm-game-of-life</code> 경로에서 다시 실행해 주세요.</p>
<h2 id="연습해-보기"><a class="header" href="#연습해-보기">연습해 보기</a></h2>
<ul>
<li>
<p><code>wasm-game-of-life/src/lib.rs</code> 경로에 있는 <code>greet</code> 함수를
수정해서 표시되는 메세지를 커스터마이징할 수 있도록 <code>name: &amp;str</code> 매개변수를 추가해 보고, <code>wasm-game-of-life/www/index.js</code> 파일에서 <code>greet</code> 함수를 이름과 함께 호출해 보세요.
<code>wasm-pack build</code> 명령어로 <code>.wasm</code> 바이너리를 다시 빌드하고, <a href="http://localhost:8080/">http://localhost:8080/</a> 페이지를 새로고침하면 브라우저에서 수정된 알림 메세지를 확인할 수 있습니다.</p>
<details>
  <summary>정답</summary>
<p><code>wasm-game-of-life/src/lib.rs</code> 파일에서 새롭게 수정된 <code>greet</code> 함수:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!("Hello, {}!", name));
}
<span class="boring">}</span></code></pre></pre>
<p><code>wasm-game-of-life/www/index.js</code> 파일에서 수정된 <code>greet</code> 함수 호출하기:</p>
<pre><code class="language-js">wasm.greet("Your Name");
</code></pre>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conways-game-of-life의-규칙"><a class="header" href="#conways-game-of-life의-규칙">Conway's Game of Life의 규칙</a></h1>
<p><em>Note: 이미 Conway's Game of Life 와 이 게임의 규칙을 잘 알고 있다면 다음 섹션으로 넘어가도 괜찮습니다.</em></p>
<p><a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Wikipedia에 Conway's Game of Life의 규칙이 아주 잘 설명돼 있습니다.</a></p>
<blockquote>
<p>Game of Life의 세상(universe)은 사각형 세포로 이루어진 무한한 사이즈의 2차원 <a href="https://ko.wikipedia.org/wiki/%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95_%ED%85%8C%EC%85%80%EB%A0%88%EC%9D%B4%EC%85%98">정사각형_테셀레이션</a>인데,
각각의 세포는 살아있거나 죽어있거나, 혹은 "주거"나 "무주거" 중 한 상태일 수 있습니다.
각 세포은 수평, 수직, 혹은 대각선으로 이웃하는 여덟개의 이웃 세포과 상호작용합니다.
매 단계마다, 다음 전이가 발생합니다.</p>
<ol>
<li>인구 부족으로 2개 미만의 이웃을 가진 세포는 죽게 됩니다.</li>
<li>2개 혹은 3개의 이웃을 가진 세포는 다음 세대에서 계속 살아있습니다.</li>
<li>과잉 인구로 3개 초과의 이웃을 가진 모든 세포는 죽게 됩니다.</li>
<li>세포 증식으로 정확히 3개의 이웃을 가진 세포는 살아나게 됩니다.</li>
</ol>
<p>이 초기 패턴은 게임 시스템의 시작점(seed)을 만들게 됩니다. 위 규칙들을 시작점(seed)의 모든 세포에
적용하면서 첫 번째 세대가 생성되게 됩니다. 출생과 사망은 동시에 일어나고, 이가 발생하는
각각의 순간을 틱(tick) 이라고 부릅니다. (다시 말해, 각 세대는 직전 세대의 순수 함수입니다.)
이 규칙은 계속 적용되어 반복적으로 추가 세대를 만듭니다.</p>
</blockquote>
<p>다음 이미지를 초기 세상이라고 생각해 봅시다:</p>
<img src='../images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />
<p>다음 세대를 계산할 때 하나씩 각 세포를 고려해 볼 수 있는데, 한번 살펴보도록 합시다. 이 초기 세상에서 왼쪽 최상단 세포는 죽어있습니다. 규칙 (4)는 죽어있는 세포에만 적용되는 유일한 전이 세포이지만, 최상단 왼쪽 세포는 정확히 3개의 살아있는 이웃을 가지고 있지 않기 때문에 전이 규칙이 적용되지 않고 다음 세대에서도 죽어 있는 상태로 유지됩니다. 동일한 이유로 첫 번째 행의 다른 세포들도 그대로 죽어있게 됩니다.</p>
<p>두 번째 행, 세번째 열의 살아있는 세포를 보면 매우 흥미로운 내용을 확인할 수 있는데, 세포가 살아있다면 첫번째 세 규칙이 적용될 수도 있습니다. 이 세포는 단 한 개의 살아있는 이웃을 가지고 있기 때문에 규칙 (1)이 적용되게 되어 다음 세대에서 죽게 됩니다. 최하단의 살아있는 세포도 동일하게 죽습니다.</p>
<p>가운데에 위치한 살아있는 세포는 위아래로 두 개의 살아있는 이웃을 가지고 있습니다. 그러므로 규칙 (2)가 적용이 되어 다음 세대에서도 살아있게 됩니다.</p>
<p>마지막으로 가운데에 살아있는 세포들의 왼쪽과 오른쪽 이웃들을 보면 정말 흥미로운 부분을 확인할 수 있는데, 이 3개의 살아있는 세포들은 양쪽 방향으로 두 세포들과 이웃해 있기 때문에 규칙 (4)가 적용이 됩니다. 그러므로 이 세포들은 다음 세대에서 살아있게 됩니다.</p>
<p>위에서 다룬 내용을 토대로, 다음 틱의 세상은 이렇게 보이게 됩니다:</p>
<img src='../images/game-of-life/next-universe.png' alt='다음 세상' width=80 />
<p>이러한 간단하고 결정적인 규칙을 적용하는 것으로 다음과 같은 이상하지만 흥미로운 동작을 확인할 수 있게 됩니다:</p>
<div class="table-wrapper"><table><thead><tr><th>Gosper's glider gun</th><th>Pulsar</th><th>Space ship</th></tr></thead><tbody>
<tr><td><img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="Gosper&#39;s glider gun" /></td><td><img src="https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif" alt="Pulsar" /></td><td><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif" alt="Lighweight space ship" /></td></tr>
</tbody></table>
</div><center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/C2vgICfQawE?rel=0&amp;start=65" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</center>
<h2 id="연습해-보기-1"><a class="header" href="#연습해-보기-1">연습해 보기</a></h2>
<ul>
<li>
<p>방금 보여드린 다음 틱 예시 이후, 그 다음 틱을 스스로 계산해 보세요. 어떻게 감이 오시는 것 같나요?</p>
<details>
  <summary>정답</summary>
<p>초기 상태의 우주로 다시 돌아가게 됩니다.</p>
  <img src='../images/game-of-life/initial-universe.png' alt='초기 상태의 우주' width=80 />
<p>이 패턴은 주기적입니다. 그러므로 두 틱마다 처음 상태로 돌아가게 됩니다.</p>
</details>
</li>
<li>
<p>"안정된" 초기 세상을 찾아보실 수 있으신가요? 세대가 바뀌어도 내용이 바뀌지 않는 세상을 찾아보세요.</p>
<details>
  <summary>정답</summary>
<p>안정된 세상은 무한하게 많습니다. 지루하게도 텅 비어있는 세상도 안정된 세상이고, 살아있는 세포들이 2 x 2 사이즈의 사각형 모양을 형성할 때도 안정된 세상을 확인할 수 있습니다.</p>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conways-game-of-life-구현하기"><a class="header" href="#conways-game-of-life-구현하기">Conway's Game of Life 구현하기</a></h1>
<h2 id="설계"><a class="header" href="#설계">설계</a></h2>
<p>시작하기 전에, 어떤 방식으로 Game of Life를 설계할지 살펴봅시다.</p>
<h3 id="무한한-세상"><a class="header" href="#무한한-세상">무한한 세상</a></h3>
<p>Game of Life는 무한한 세상에서 시작됩니다. 하지만 보통은 우리가 무한한 메모리와 컴퓨터 파워를 가지고 있지 않기 때문에 다음 세 가지 방법 중 한 방법을 통해 이 귀찮은 제한을 우회하게 됩니다:</p>
<ol>
<li>
<p>세상의 어떤 부분이 많은 컴퓨터 자원을 필요로 하는지 추적하고 이러한 부분을 필요할 때 확장합니다. 최악의 경우에는, 이 확장이 제한 없이 진행되고 코드가 계속해서 느려지면서 결국에는 메모리를 다 차지하게 됩니다.</p>
</li>
<li>
<p>모서리에 위치한 세포들이 가운데에 위치한 세포들과 비교해서 더 적은 이웃을 가지게 되는 사이즈가 정해져 있는 세상을 만듭니다. 이 방법에는 <a href="https://conwaylife.com/wiki/Glider">gliders</a>와 같은 무한한 패턴이 모서리에서 끝나버리게 된다는 단점이 있습니다.</p>
</li>
<li>
<p>사이즈가 정해졌지만 계속해서 연결되는 우주를 만듭니다. 세상의 끝을 반대쪽 세상의 끝으로 연결시켜 세포들이 계속해서 이웃을 가질 수 있게 합니다. 이렇게 gliders 패턴이 계속 움직일 수 있게 됩니다.</p>
</li>
</ol>
<p>그러면 세 번째 방법으로 구현을 해보겠습니다.</p>
<h3 id="rust와-javascript-코드끼리-연결하기"><a class="header" href="#rust와-javascript-코드끼리-연결하기">Rust와 JavaScript 코드끼리 연결하기</a></h3>
<blockquote>
<p>⚡ 다음 내용은 이 튜토리얼에서 다루는 내용 중에서도 아주 중요한 내용입니다. 이 내용을 이해하면서 얻어갈 수 있는 부분이 아주 많습니다!</p>
</blockquote>
<p>JavaScript는 <code>Object</code>, <code>Array</code> 그리고 <a href="https://developer.mozilla.org/ko/docs/Glossary/Node/DOM">DOM 노드 (node)</a> 들이 할당되는 가비지 콜렉터가 관리하는 힙을 사용하지만, 작성하게 될 Rust 코드의 선형 메모리는 별개의 공간을 사용하게 됩니다. WebAssembly는 현재로써는 가비지 콜렉터가 관리하는 힙에 직접 접근할 수 없습니다. (2018년 4월 기준으로, <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">"인터페이스 타입" 제안</a> 과 함께 변경될 전망이긴 합니다.) 반면에 JavaScript는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>나 스칼라 값 (scalar values / <code>u8</code>, <code>i32</code>, <code>f64</code>, 등...) 만으로라도 이 선형 메모리를 읽고 쓸 수 있습니다. 이런 내용을 기반으로 모든 WebAssembly와 JavaScript 사이의 커뮤니케이션이 구성되게 됩니다.</p>
<p><code>wasm_bindgen</code>는 이 경계를 사이로 어떻게 구조체 (compound structure) 들을 주고받아야 하는지 정해주는 역할을 합니다. 이러한 작업은 Rust 구조체를 박싱(boxing)하고, 쉽게 사용하기 위해 JavaScript 클래스에 포인터를 랩핑(wrapping)하고, Rust 코드에서 JavaScript 객체 테이블을 인덱싱(indexing)하는 과정을 포함합니다. <code>wasm_bindgen</code>은 매우 간편하지만, 데이터 표현 설계를 모두 대신 해주진 않습니다. 원하는 방식으로 인터페이스 설계를 구현할 수 있도록 도와주는 도구 정도로 생각하면 좋습니다.</p>
<p>WebAssembly와 JavaScript 사이의 인터페이스를 설계할 때, 다음 내용들을 최적화 작업 시 고려해야 합니다:</p>
<ol>
<li>
<p><strong>JavaScript와 WebAssembly 선형 메모리 사이를 오가는 복사(copy) 최소화하기.</strong>
불필요한 복사는 불필요한 오버헤드를 발생시킵니다.</p>
</li>
<li>
<p><strong>직렬화(serializing)와 역직렬화(deserializing) 최소화하기.</strong> 복사와 마찬가지로, 직렬화와 역직렬화도 오버헤드를 발생시킬 수 있고, 이러한 작업이 복사도 자주 발생시키게 됩니다. 한 곳에서 모든 직렬화 작업을 하는 대신 일반적으로 WebAssembly 선형 메모리의 알려진 위치로 <a href="https://en.wikipedia.org/wiki/Opaque_data_type">opaque handle</a>들을 넘기는 방식으로 많은 오버헤드를 줄일수 있게 됩니다. 그리고 <code>wasm_bindgen</code>을 통해 JavaScript의 <code>Object</code>나 박싱된 Rust <code>struct</code>를 가리키는 opaque handle들을 더 쉽게 정의하고 사용할 수 있습니다.</p>
</li>
</ol>
<p>대부분의 경우에는, JavaScript와 WebAssembly를 오갈 때 사이즈가 크고 오래 살아있어야 하는 자료 구조를 WebAssembly 선형 메모리에 두고, 이러한 값들을 JavaScript에서 opaque handle로써 노출시키는 것이 좋은 인터페이스 설계입니다. JavaScript가 이러한 opaque handle를 통해 WebAssembly 함수를 호출하고, 데이터를 변형시키고, 무거운 컴퓨팅 작업을 하고, 값을 검색하고, 최종적으로 작은 사이즈의 복사할 수 있는 값을 반환하게 됩니다. 작은 값만 반환하게 되면 JavaScript 가비지 콜렉터가 관리하는 힙과 WebAssembly 선형 메모리 사이의 모든 값들을 앞뒤로 복사하고 직렬화할 필요가 없어지게 됩니다.</p>
<h3 id="rust와-javascript를-구현하는-프로그램에서-조작하기"><a class="header" href="#rust와-javascript를-구현하는-프로그램에서-조작하기">Rust와 JavaScript를 구현하는 프로그램에서 조작하기</a></h3>
<p>위험한 사례를 살펴보는 것으로 시작해봅시다. 매 틱마다 세상을 WebAssembly에서 불러오거나 가져오기 위해 복사하지 않아야 하고, 세포 하나씩 객체를 모두 할당하거나 경계를 오가면서 읽고 쓰는 것도 좋지 않습니다.</p>
<p>그렇다면 어떻게 구현하는 게 좋을까요? 죽은 세포를 <code>0</code>로 나타내고 살아있는 세포를 <code>1</code>로 나타내는 식으로 세포들을 각각 1 byte 값으로 나타내볼 수도 있는데, WebAssembly 선형 메모리에 1차원 배열로 나타내봅시다.</p>
<p>4 x 4 사이즈의 우주를 메모리 이미지로 표현해 보겠습니다:</p>
<p><img src="game-of-life/../images/game-of-life/universe.png" alt="4 x 4 사이즈 세상의 스크린샷" /></p>
<p>이 공식을 사용해서 주어진 열과 행에 해당하는 배열 인덱스를 찾을 수 있습니다:</p>
<pre><code class="language-text">index(row, column, universe) = row * width(universe) + column
</code></pre>
<p>세포들을 JavaScript에 노출시킬때 여러 가지 방법을 사용해볼수 있는데, 우선은 Rust <code>String</code> 타입의 값으로 세포들을 문자로 표시할 수 있도록 <code>Universe</code> 타입에 <code>std::fmt::Display</code> 트레이트를 구현해 주도록 합시다. 이 트레이트를 통해 Rust <code>String</code> 타입의 값을 WebAssembly 선형 메모리에서 JavaScript 가비지 콜렉터가 관리하는 힙으로 복사할 수 있게 됩니다. 그 다음, 복사된 값을 HTML <code>textConent</code>에 표시해 보도록 하겠습니다. 이 챕터 후반에서는 이 구현에 덧붙여서 세포들을 힙에 복사하지 않도록 해보고 세포들을 <code>&lt;canvas&gt;</code>에 표시해볼 예정입니다.</p>
<p><em>하나 더 대신 해볼 법한 설계가 있는데, 세상 전체를 노출시키지 않고 매 틱마다 상태가 바뀌게 되는 세포들을 목록으로 만들어서 Rust 코드에서 JavaScript로 반환해 볼 수도 있습니다. 이 방법으로, JavaScript 코드에서 세상 전체를 순회할 필요 없이 일부만 순회할 수 있게 됩니다. 단점으로는, 이 델타 기반 (delta-based)의 설계는 구현하기가 조금 더 어렵습니다.</em></p>
<h2 id="rust-코드-구현하기"><a class="header" href="#rust-코드-구현하기">Rust 코드 구현하기</a></h2>
<p>직전 챕터에서 초기 프로젝트 템플릿을 클론했는데, 이 템플릿을 한번 수정해 보도록 합시다.</p>
<p><code>alert</code>를 임포트하는 줄과 <code>greet</code> 함수를 <code>wasm-game-of-life/src/lib.rs</code> 파일에서 지워보고, 세포의 타입 정의를 대신 추가해 주는 것으로 시작해 보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
<span class="boring">}</span></code></pre></pre>
<p>각 세포가 1 byte 사이즈로 표현돼야 하므로 <code>#[repr(u8)]</code>을 잊지 않고 붙여주도록 하고, 세포 주변에 살아있는 이웃들을 쉽게 셀 수 있도록, <code>0</code>를 <code>Dead</code>로, <code>1</code>을 <code>Alive</code>로 정해주는 것도 중요합니다.</p>
<p>그다음, 세상을 정의해봅시다. 세상을 나타내는 구조체는 너비와 높이, 세포들을 나타내는 <code>width * height</code> 크기의 벡터(vector)를 필드로 가지게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>이전에 설명한 내용대로 주어진 행과 열을 세포 벡터의 인덱스로 변환하여 사용할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>세포의 다음 상태를 계산하려면 몇 개의 이웃이 살아있는지 확인해야 합니다. 이 내용을 토대로 <code>live_neighbor_count</code> 메소드를 작성해 봅시다!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    // ...

    fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 &amp;&amp; delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>live_neighbor_count</code> 메소드는 델타값과 나머지 값을 각각 확인해서 세상의 가장자리에서 발생할 수 있는 예외를 <code>if</code> 문으로 처리해 줍니다. <code>-1</code>의 델타를 적용할 때, <code>self.height - 1</code>을 추가해서 <code>1</code>을 빼는 대신 나머지 값을 계속 처리하고, <code>row</code>와 <code>column</code>은 각각 <code>0</code>이 될 수 있습니다. 이 <code>row</code>와 <code>column</code> 값에서 <code>1</code>을 빼려고 시도할 때, unsigned integer underflow 가 발생하게 됩니다.</p>
<p>이제 현재 세대를 기반으로 다음 세대를 처리하는 데 필요한 준비가 완료됐습니다! <code>match</code> 문을 사용해서 게임의 규칙을 보기 명확하게 나타내봅시다. 추가로 틱이 일어날 때 JavaScript가 컨트롤하도록 할 예정이기 때문에, <code>#[wasm_bindgen]</code> 블럭을 추가해서 이 메소드를 JavaScript 코드에 노출시켜보도록 하겠습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public 메소드, JavaScript로 익스포트 할 수 있도록 함.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&amp;mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // 규칙 1: 인구 부족으로 2개 미만의 이웃을 가진 세포는 죽게 됩니다.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // 규칙 2: 2개 혹은 3개의 이웃을 가진 세포는 다음 세대에서 계속 살아있습니다.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: 과잉 인구로 3개 초과의 이웃을 가진 모든 세포는 죽게 됩니다.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // 규칙 4: 세포 증식으로 정확히 3개의 이웃을 가진 세포는 살아나게 됩니다.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // 규칙이 적용되지 않는 세포들의 상태는 그대로 유지되게 됩니다.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>지금까지는 세상의 상태를 세포들의 벡터로 나타냈습니다. 조금 더 사람이 읽기 쉽도록 텍스트 렌더러 (text renderer) 를 구현해 보도록 합시다. 세상을 한줄 한줄씩 텍스트로 표현을 해보도록 하는데, 살아있는 세포들을 유니코드 문자 <code>◼</code> ("black medium square") 로 나타내고 죽은 세포들을 <code>◻</code> ("white medium square") 로 표현해 보겠습니다.</p>
<p>또한, Rust 스탠다드 라이브러리의 <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a> 트레이트를 구현해서 사람이 읽기 쉬운 방식으로 포맷할 수 있도록 메소드를 추가해 보겠습니다. 이 트레이트를 구현하면 자동적으로 Universe의 인스턴스(instance)들이 <a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a> 메소드를 사용할 수 있게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
                write!(f, "{}", symbol)?;
            }
            write!(f, "\n")?;
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>마지막으로 <code>render</code> 메소드와 함께 생성자를 정의해서 세포들이 살아나고 죽어가는 신기한 세상을 생성할 수 있도록 해보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public 메소드, JavaScript로 익스포트 할 수 있도록 함.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -&gt; Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&amp;self) -&gt; String {
        self.to_string()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>드디어 Game of Life의 Rust 코드 구현이 끝났습니다!</p>
<p>이제 <code>wasm-game-of-life</code> 경로에서 <code>wasm-pack build</code>를 실행해서 WebAssembly 파일을 다시 컴파일해 주세요.</p>
<h2 id="javascript로-페이지-렌더링하기"><a class="header" href="#javascript로-페이지-렌더링하기">JavaScript로 페이지 렌더링하기</a></h2>
<p><code>wasm-game-of-life/www/index.html</code>에 <code>&lt;pre&gt;</code> 요소를 추가해서 세상을 렌더링해 봅시다. <code>&lt;pre&gt;</code> 요소를 <code>&lt;script&gt;</code> 태그 바로 위에 추가해 주세요:</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;pre id="game-of-life-canvas"&gt;&lt;/pre&gt;
  &lt;script src="./bootstrap.js"&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>추가로, <code>&lt;pre&gt;</code> 가 웹사이트 중간에 표시될 수 있도록 CSS flex box를 사용해 봅시다. <code>wasm-game-of-life/www/index.html</code> 파일을 열고 <code>&lt;head&gt;</code> 내에 <code>&lt;style&gt;</code> 태그를 추가해 주세요:</p>
<pre><code class="language-html">&lt;style&gt;
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
&lt;/style&gt;
</code></pre>
<p>이제 <code>wasm-game-of-life/www/index.js</code> 파일 최상단 위치한 기존 <code>greet</code> 함수를 지우고 <code>Universe</code>를 임포트하는 줄을 추가해 주세요.</p>
<pre><code class="language-js">import { Universe } from "wasm-game-of-life";
</code></pre>
<p><code>&lt;pre&gt;</code> 요소를 <code>pre</code> 상수에 담은 다음 새 우주를 시작해 봅시다.</p>
<pre><code class="language-js">const pre = document.getElementById("game-of-life-canvas");
const universe = Universe.new();
</code></pre>
<p>이 JavaScript 함수는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame</code> 루프</a>로 실행해서 매 반복마다 업데이트된 세상을 <code>&lt;pre&gt;</code>에 반영하고 <code>Universe::tick</code>을 호출합니다.</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>렌더링 처리를 시작하려면 다음 코드를 <code>renderLoop</code> 함수 밖에 추가해서 렌더링 루프를 시작해 주세요:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<p>다시 한번 (<code>npm run</code>을 <code>wasm-game-of-life/www</code> 경로에서 실행한) 개발 서버가 아직 구동 중인지 확인해 주세요. <a href="http://localhost:8080/">http://localhost:8080/</a> 페이지를 열면 다음 내용을 확인할 수 있게 됩니다:</p>
<p><a href="game-of-life/../images/game-of-life/initial-game-of-life-pre.png"><img src="game-of-life/../images/game-of-life/initial-game-of-life-pre.png" alt="텍스트를 렌더하는 Game of Life 구현 스크린샷" /></a></p>
<h2 id="메모리에서-바로-캔버스로-렌더링하기"><a class="header" href="#메모리에서-바로-캔버스로-렌더링하기">메모리에서 바로 캔버스로 렌더링하기</a></h2>
<p>Rust 코드에서 <code>String</code>을 생성 (및 할당) 하고 <code>wasm-bindgen</code>로 이 생성한 값을 유효한 JavaScript 문자열로 변환하면 세포들을 불필요하게 복사하게 됩니다. 우리가 JavaScript 코드에서 세상의 너비와 높이를 이미 알고 있고, 세포를 만드는 처리가 이루어지는 WebAssembly 선형 메모리를 읽을 수 있기 때문에, <code>render</code> 메소드를 수정하여 <code>cells</code> 배열의 시작을 가리키는 포인터를 대신 반환해 보도록 합시다.</p>
<p>그리고 유니코드 문자를 렌더링하지 않고 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a> 를 대신 사용해 봅시다. 이 API를 이 부분 이후부터 계속 사용하겠습니다.</p>
<p><code>wasm-game-of-life/www/index.html</code> 파일에서 이전에 추가한 <code>&lt;pre&gt;</code>를 지우고 렌더링에 사용할 <code>&lt;canvas&gt;</code>를 추가해주세요. (<code>&lt;body&gt;</code> 태그 내에서 JavaScript 코드를 시작시키는 <code>&lt;script&gt;</code> 태그 위에 추가돼야 합니다.)</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;canvas id="game-of-life-canvas"&gt;&lt;/canvas&gt;
  &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>Rust로 구현한 코드에서 필요한 정보를 얻어올 수 있도록 세상의 넓이, 너비, 세포 배열을 가리키는 포인터를 반환하는 getter 함수들을 조금 더 작성해 보겠습니다. 이 함수들도 JavaScript 코드로 노출시켜야 하니 잘 확인해 주고, <code>wasm-game-of-life/src/lib.rs</code> 파일에 다음 코드를 추가해 주세요:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public 메소드, JavaScript로 익스포트 할 수 있도록 함.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&amp;self) -&gt; u32 {
        self.width
    }

    pub fn height(&amp;self) -&gt; u32 {
        self.height
    }

    pub fn cells(&amp;self) -&gt; *const Cell {
        self.cells.as_ptr()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>그 다음, <code>wasm-game-of-life/www/index.js</code> 파일의 <code>wasm-game-of-life</code> 모듈에서 <code>Cell</code>을 임포트하는 줄을 추가해 준 다음 캔버스를 렌더링할 때 사용할 상수 몇 가지를 정의해주세요:</p>
<pre><code class="language-js">import { Universe, Cell } from "wasm-game-of-life";

const CELL_SIZE = 5; // px
const GRID_COLOR = "#CCCCCC";
const DEAD_COLOR = "#FFFFFF";
const ALIVE_COLOR = "#000000";
</code></pre>
<p>이제 <code>&lt;pre&gt;</code> 태그의 <code>textContent</code> 대신에 <code>&lt;canvas&gt;</code>를 업데이트 할 수 있도록 JavaScript 나머지 코드를 다시 작성해주세요:</p>
<pre><code class="language-js">// Universe를 생성하고 너비와 높이를 반환받습니다.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// 캔버스에 세포들을 표시할 공간을 만들어주고, 각 세포들이 1px 두께의 테두리를 가질 수 있도록 해줍니다.
const canvas = document.getElementById("game-of-life-canvas");
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () =&gt; {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>세포들 사이에 격자를 그리려면 일정한 간격으로 나란히 놓인 수평선과 수직선을 그려줍니다. 이러한 선들은 교차하여 격자를 형성하게 됩니다.</p>
<pre><code class="language-js">const drawGrid = () =&gt; {
  ctx.beginPath();
  ctx.strokeStyle = GRID_COLOR;

  // 수직줄
  for (let i = 0; i &lt;= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // 수평줄
  for (let j = 0; j &lt;= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<p>raw wasm 모듈인 <code>wasm_game_of_life_bg</code>에 정의된 <code>memory</code>를 임포트해서 WebAssembly의 선형 메모리에 직접 접근할 수 있습니다. 세포를 그리려면 우선 세상에 있는 세포들을 가리키는 포인터를 반환받고 세포 버퍼(buffer)를 오버레이(overlay)하는 <code>Uint8Array</code> 객체를 생성해야 합니다. 그 다음 각 세포를 순회하여 생존 여부에 따라 흰색 또는 검은색 사각형을 그립니다. 포인터를 오버레이 하게 되면서, 모든 틱마다 세포들을 복사하지 않도록 최적화 작업을 해줄 수 있습니다.</p>
<pre><code class="language-js">// WebAssembly 메모리를 파일 최상단에 임포트 해줍니다.
import { memory } from "wasm-game-of-life/wasm_game_of_life_bg";

// ...

const getIndex = (row, column) =&gt; {
  return row * width + column;
};

const drawCells = () =&gt; {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === Cell.Dead
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<p>이전에 보여드린 코드를 사용해서 렌더링 처리를 시작해 보겠습니다:</p>
<pre><code class="language-js">drawGrid();
drawCells();
requestAnimationFrame(renderLoop);
</code></pre>
<p><code>drawGrid()</code>와 <code>drawCells()</code> 두 함수를 <code>requestAnimationFrame()</code> 함수 호출 <em>이전에</em> 호출해야 한다는 점을 꼭 기억해 주세요. <em>초기</em> 상태의 세상이 그려진 이후에 수정 사항을 적용해야 합니다. <code>requestAnimationFrame(renderLoop)</code> 함수만 호출하게 된다면 <code>universe.tick()</code>이 호출된 <em>이후</em> 시점의 두 번째 틱이 대신 그려지게 됩니다.</p>
<h2 id="다-됐어요"><a class="header" href="#다-됐어요">다 됐어요!</a></h2>
<p>최상단 <code>wasm-game-of-life</code> 경로에서 다음 명령어를 실행하여 WebAssembly와 바인딩 파일 (bindings glue) 들을 다시 빌드해줍시다:</p>
<pre><code>wasm-pack build
</code></pre>
<p>다시 한번 개발 서버가 아직 구동 중인지 확인해주세요. 구동 중이지 않다면 <code>wasm-game-of-life/www</code> 경로에서 다시 시작해주세요:</p>
<pre><code>npm run start
</code></pre>
<p><a href="http://localhost:8080/">http://localhost:8080/</a> 페이지를 웹 브라우저에서 새로고침하면 구현된 흥미진진한 Game of Life가 시작되게 됩니다.</p>
<p><a href="game-of-life/../images/game-of-life/initial-game-of-life.png"><img src="game-of-life/../images/game-of-life/initial-game-of-life.png" alt="Game of Life 구현 스크린샷" /></a></p>
<p>추가로 관심이 있다면, <a href="https://en.wikipedia.org/wiki/Hashlife">hashlife</a> 라는 엄청 멋진 Game of Life 알고리즘 구현도 있으니 한번 확인해 보세요. 이 알고리즘은 공격적인 메모이제이션 (aggressive memoizing) 기법을 사용하는데, 덕분에 코드가 더 오래 구동되는 만큼 미래 세대들을 <em>기하급수적으로 더 빠르게</em> 계산할 수 있게 해줍니다. hashlife를 이 튜토리얼에서 구현해 보면 정말 재밌겠지만, 이 책은 Rust와 WebAssembly 사용에 중점을 두고 있으므로 다루지 않도록 하겠습니다. 하지만 hashlife에 대해 따로 배워보길 적극적으로 권장합니다.</p>
<h2 id="연습해-보기-2"><a class="header" href="#연습해-보기-2">연습해 보기</a></h2>
<ul>
<li>
<p><a href="https://conwaylife.com/wiki/Spaceship">space ship</a> 패턴 하나를 표시하는 세상을 만들어보세요.</p>
</li>
<li>
<p>초기 세상을 하드코딩 하는 대신, 각 세포가 50% 확률로 살아있거나 죽어있는 상태로 랜덤하게 생성될 수 있도록 해보세요.</p>
<p><em>힌트: <a href="https://crates.io/crates/js-sys">the <code>js-sys</code> crate</a> 크레이트를 사용하여 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random"><code>Math.random</code> JavaScript 함수</a>를 임포트해보세요.</em></p>
<details>
  <summary>정답</summary>
<p><em>먼저, <code>wasm-game-of-life/Cargo.toml</code> 파일을 열고 <code>js-sys</code>를 종속성으로 추가해 주세요:</em></p>
<pre><code class="language-toml"># ...
[dependencies]
js-sys = "0.3"
# ...
</code></pre>
<p><em>그 다음 <code>js_sys::Math::random</code> 함수를 사용해서 50% 확률로 값을 결정해 주세요:</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate js_sys;

// ...

if js_sys::Math::random() &lt; 0.5 {
    // 세포가 살아있게 함
} else {
    // 세포가 죽어있게 함
}
<span class="boring">}</span></code></pre></pre>
</details>
</li>
<li>
<p>각 세포를 byte 값으로 표현하면서 순회를 쉽게 할 수 있지만, 메모리 자원을 낭비한다는 단점이 있습니다. 1 byte는 8 bit인데, 실제로 세포 생존 여부를 표시할 때는 1 bit만 사용하고 있습니다. 이 데이터 표현들을 리팩토링하여 각 세포가 1 bit의 사이즈만 사용할 수 있도록 코드를 작성해 보세요.</p>
<details>
  <summary>정답</summary>
<p>Rust 언어에서 <code>Vec&lt;Cell&gt;</code> 타입 대신 (추가 기능을 제공하는 라이브러리인) <a href="https://crates.io/crates/fixedbitset"><code>fixedbitset</code> 크레이트의 <code>FixedBitSet</code> 타입</a>을 사용하여 세포들을 나타내볼 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Cargo.toml에 종속성을 추가했는지 확인해 주세요!
extern crate fixedbitset;
use fixedbitset::FixedBitSet;

// ...

#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: FixedBitSet,
}
<span class="boring">}</span></code></pre></pre>
<p>Universe의 생성자를 다음과 같이 수정해 보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    let width = 64;
    let height = 64;

    let size = (width * height) as usize;
    let mut cells = FixedBitSet::with_capacity(size);

    for i in 0..size {
        cells.set(i, i % 2 == 0 || i % 7 == 0);
    }

    Universe {
        width,
        height,
        cells,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>다음 틱에서 세포를 업데이트할 수 있도록 <code>FixedBitSet</code> 타입의 <code>set</code> 메소드를 사용해 봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>next.set(idx, match (cell, live_neighbors) {
    (true, x) if x &lt; 2 =&gt; false,
    (true, 2) | (true, 3) =&gt; true,
    (true, x) if x &gt; 3 =&gt; false,
    (false, 3) =&gt; true,
    (otherwise, _) =&gt; otherwise
});
<span class="boring">}</span></code></pre></pre>
<p>JavaScript에서 시작하는 bit를 가리키는 포인터를 반환해야 하므로, <code>FixedBitSet</code> 타입을 슬라이스(slice)로 변환한 다음 변환된 슬라이스를 포인터로 다시 변환해 주세요:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe {
    // ...

    pub fn cells(&amp;self) -&gt; *const u32 {
        self.cells.as_slice().as_ptr()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>JavaScript의 wasm 메모리에서 <code>Uint8Array</code>를 생성해오는 방법은 이전과 동일합니다. 하지만 이번에는 각 세포를 나타내기 위해 byte 대신 bit을 사용하므로 배열의 길이가 더 이상 <code>width * height</code>가 아니고 <code>width * height / 8</code>이 되어야 하니 다시 잘 확인해 주세요:</p>
<pre><code class="language-js">const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);
</code></pre>
<p>다음 함수를 사용하여 인덱스와 <code>Uint8Array</code>가 주어질 때 <em>n</em>번째 bit의 값이 0인지 1인지 확인할 수 있습니다:</p>
<pre><code class="language-js">const bitIsSet = (n, arr) =&gt; {
  const byte = Math.floor(n / 8);
  const mask = 1 &lt;&lt; (n % 8);
  return (arr[byte] &amp; mask) === mask;
};
</code></pre>
<p>이제 준비가 됐으니 <code>drawCells</code> 함수를 다음과 같이 업데이트해줍시다:</p>
<pre><code class="language-js">const drawCells = () =&gt; {
  const cellsPtr = universe.cells();

  // 수정된 부분입니다!
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      // 수정된 부분입니다!
      ctx.fillStyle = bitIsSet(idx, cells)
        ? ALIVE_COLOR
        : DEAD_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-of-life-테스팅하기"><a class="header" href="#game-of-life-테스팅하기">Game of Life 테스팅하기</a></h1>
<p>브라우저 JavaScript 환경에서 실행할 수 있도록 Game of Life를 구현했으니 이제 Rust 코드에서 WebAssembly 함수를 테스팅하는 방법에 대해 알아봅시다.</p>
<p><code>tick</code> 함수로 예상값과 일치하는 올바른 값을 불러올 수 있는지 테스팅 해보겠습니다.</p>
<p>우선 테스팅을 작성하기 전에 <code>wasm_game_of_life/src/lib.rs</code> 파일에 작성한 <code>impl Universe</code> 블럭 내부에 setter 함수와 getter 함수들을 조금 더 작성해 보겠습니다. <code>set_width</code>와 <code>set_height</code> 함수를 작성해서 다른 사이즈의 <code>Universe</code>들을 만들어볼 수 있도록 해봅시다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe { 
    // ...

    /// 세상의 너비를 설정합니다.
    ///
    /// 모든 세포를 죽은 상태로 리셋합니다.
    pub fn set_width(&amp;mut self, width: u32) {
        self.width = width;
        self.cells = (0..width * self.height).map(|_i| Cell::Dead).collect();
    }

    /// 세상의 넓이를 설정합니다.
    ///
    /// 모든 세포를 죽은 상태로 리셋합니다.
    pub fn set_height(&amp;mut self, height: u32) {
        self.height = height;
        self.cells = (0..self.width * height).map(|_i| Cell::Dead).collect();
    }

}
<span class="boring">}</span></code></pre></pre>
<p><code>wasm_game_of_life/src/lib.rs</code> 파일에 <code>#[wasm_bindgen]</code> 속성 없이 <code>impl Universe</code> 블럭을 하나 더 만들어보겠습니다. 추가로 테스팅에 사용하는 데 필요한 함수가 몇 개 있는데, 이 함수들은 JavaScript로 노출시키지 않아야 합니다. Rust로 생성한 WebAssembly 함수는 대여한 참조를 반환하지 못하는데, 이 함수들 위에 <code>#[wasm_bindgen]</code> 속성을 추가해 보고 어떤 에러를 확인할 수 있게 되는지 살펴봅시다.</p>
<p><code>get_cells</code> 함수를 구현해서 <code>Universe</code>의 <code>cells</code> 필드 값을 가져와 보겠습니다. <code>set_cells</code> 함수도 작성해서 주어진 행과 열에 위치한 <code>Universe</code>의 세포를 <code>Alive</code> 상태로 업데이트할 수 있도록 해보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    /// 세상에 존재하는 모든 죽어있는 세포와 살아있는 세포를 반환합니다.
    pub fn get_cells(&amp;self) -&gt; &amp;[Cell] {
        &amp;self.cells
    }

    /// 배열로 주어진 행과 열들을 확인하고 세포들을 살아있는 상태로 업데이트합니다.
    pub fn set_cells(&amp;mut self, cells: &amp;[(u32, u32)]) {
        for (row, col) in cells.iter().cloned() {
            let idx = self.get_index(row, col);
            self.cells[idx] = Cell::Alive;
        }
    }

}
<span class="boring">}</span></code></pre></pre>
<p>이제 <code>wasm_game_of_life/tests/web.rs</code> 파일에 테스팅 코드를 작성해 보도록 하겠습니다.</p>
<p>진행하기 전에, 이미 완성된 테스팅 코드가 있으니 한번 살펴봅시다. <code>wasm-game-of-life</code> 경로에서 <code>wasm-pack test --chrome --headless</code> 명령어를 실행하여 Rust로 생성한 WebAssembly 테스팅 코드가 잘 작동하는지 확인할 수 있습니다. <code>--firefox</code>, <code>--safari</code>, <code>--node</code> 옵션을 사용하여 특정 브라우저 환경에서 코드를 테스트할 수도 있습니다.</p>
<p>우선 <code>wasm_game_of_life/tests/web.rs</code> 파일에서, <code>wasm_game_of_life</code> 크레이트와 <code>Universe</code>를 익스포트 해줍시다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate wasm_game_of_life;
use wasm_game_of_life::Universe;
<span class="boring">}</span></code></pre></pre>
<p><code>wasm_game_of_life/tests/web.rs</code> 파일에서 spaceship 예시 패턴을 만드는 함수들을 작성해 봅시다.</p>
<p><code>tick</code> 함수를 호출할 때 사용할 패턴과, 한 틱 이후의 결괏값을 비교할 때 사용할 예상값이 필요한데, 우선은 <code>input_spaceship</code> 함수에서 어떤 세포들을 <code>Alive</code> 상태로 생성할지 정해줍시다. <code>expected_spaceship</code> 함수를 테스트해 보는데, <code>input_spaceship</code> 호출 이후 시점 틱의 spaceship 패턴을 직접 계산해서 값을 채워보도록 하겠습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
pub fn input_spaceship() -&gt; Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&amp;[(1,2), (2,3), (3,1), (3,2), (3,3)]);
    universe
}

#[cfg(test)]
pub fn expected_spaceship() -&gt; Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&amp;[(2,1), (2,3), (3,2), (3,3), (4,2)]);
    universe
}
<span class="boring">}</span></code></pre></pre>
<p>마지막으로 <code>test_tick</code> 함수를 구현해 주도록 하겠습니다. 먼저 <code>input_spaceship()</code>와 <code>expected_spaceship()</code>를 호출해서 인스턴스들을 만들어줍시다. 그다음에 <code>input_universe</code> 인스턴스의 <code>tick</code> 함수를 호출해 주도록 합시다. 추가로, <code>assert_eq!</code> 매크로를 사용해서 <code>get_cells()</code>를 호출한 다음 <code>input_universe</code>와 <code>expected_universe</code> 가 동일한 <code>Cell</code> 타입의 배열을 값으로 가지고 있는지 확인해 보겠습니다. 마무리로는 이 코드 블럭 위에 <code>#[wasm_bindgen_test]</code> 속성을 추가해서 <code>wasm-pack test</code> 명령어로 Rust로 생성한 WebAssembly 코드를 테스트할 수 있도록 해줍시다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen_test]
pub fn test_tick() {
    // 작은 사이즈의 Universe과 spaceship 패턴을 생성해 봅시다.
    let mut input_universe = input_spaceship();

    // `input_universe` 인스턴스의 다음 틱 결괏값과 비교하게 될 spaceship 패턴입니다.
    let expected_universe = expected_spaceship();

    // `tick` 함수를 실행하고 두 `Universe`의 세포들이 동일한지 확인합니다.
    input_universe.tick();
    assert_eq!(&amp;input_universe.get_cells(), &amp;expected_universe.get_cells());
}
<span class="boring">}</span></code></pre></pre>
<p>이제 <code>wasm-game-of-life</code> 경로에서 <code>wasm-pack test --firefox --headless</code> 명령어를 실행하여 테스팅 코드를 실행해 주면 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="디버깅"><a class="header" href="#디버깅">디버깅</a></h1>
<p>코드를 더 작성하기 전에, 디버깅 툴들을 조금 살펴보고 장전해 볼까요? 관심이 있다면 <a href="game-of-life/../reference/debugging.html">Rust로 WebAssembly 바이너리를 생성하는 데 사용해 볼 수 있는 접근 방법들과 툴들에 대해 다루는 참조 페이지</a>도 확인해 보세요!</p>
<h2 id="패닉-로그-활성화하기"><a class="header" href="#패닉-로그-활성화하기">패닉 로그 활성화하기</a></h2>
<p><a href="game-of-life/../reference/debugging.html#logging-panics">코드가 패닉 할 때 개발자 콘솔에 도움이 되는 에러 메세지를 표시하면 디버깅이 더 쉬워집니다.</a></p>
<p>필수로 사용할 필요는 없지만 <code>wasm-pack-template</code>은 <code>wasm-game-of-life/src/utils.rs</code> 파일에 기본으로 활성화돼 있는 종속성인 <a href="https://github.com/rustwasm/console_error_panic_hook">the <code>console_error_panic_hook</code> 크레이트</a>를 포함합니다. 이 훅(hook)을 생성자에 포함시켜주면 이 기능을 사용할 수 있게 됩니다. <code>wasm-game-of-life/src/lib.rs</code> 파일 내의 <code>Universe::new</code> 생성자에서 불러보도록 하겠습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    utils::set_panic_hook();

    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="구현한-game-of-life에-로그-기능-추가하기"><a class="header" href="#구현한-game-of-life에-로그-기능-추가하기">구현한 Game of Life에 로그 기능 추가하기</a></h2>
<p><a href="game-of-life/../reference/debugging.html#logging-with-the-console-apis"><code>web-sys</code> 크레이트를 통해 <code>console.log</code> 함수를 사용해 보고, 매 세포들의 정보를 로그</a> 할 수 있도록 기능을 추가해 보겠습니다.</p>
<p>우선, <code>wasm-game-of-life/Cargo.toml</code> 파일을 열고 <code>web-sys</code>를 종속성으로 추가한 다음 <code>"console"</code> 기능을 활성화해 주세요:</p>
<pre><code class="language-toml">[dependencies]

# ...

[dependencies.web-sys]
version = "0.3"
features = [
  "console",
]
</code></pre>
<p>더 나은 개발자 경험을 위해 <code>console.log</code> 함수를 <code>println!</code> 스타일의 매크로로 감싸보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

// `println!(...)` 스타일의 문법을 `console.log`에 사용할 수 있게 해주는 매크로.
macro_rules! log {
    ( $( $t:tt )* ) =&gt; {
        web_sys::console::log_1(&amp;format!( $( $t )* ).into());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이제 Rust 코드에서 <code>log</code> 매크로를 호출해서 콘솔에 메세지를 로그 해봅시다. 예를 들어서, 세포의 상태, 이웃 수, 다음 틱 상태를 로그 할 수 있도록 <code>wasm-game-of-life/src/lib.rs</code> 파일을 수정해 주세요:</p>
<pre><code class="language-diff">diff --git a/src/lib.rs b/src/lib.rs
index f757641..a30e107 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -123,6 +122,14 @@ impl Universe {
                 let cell = self.cells[idx];
                 let live_neighbors = self.live_neighbor_count(row, col);

+                log!(
+                    "cell[{}, {}] is initially {:?} and has {} live neighbors",
+                    row,
+                    col,
+                    cell,
+                    live_neighbors
+                );
+
                 let next_cell = match (cell, live_neighbors) {
                     // 규칙 1: 인구 부족으로 2개 미만의 이웃을 가진 세포는 죽게 됩니다. 
@@ -140,6 +147,8 @@ impl Universe {
                     (otherwise, _) =&gt; otherwise,
                 };

+                log!("    it becomes {:?}", next_cell);
+
                 next[idx] = next_cell;
             }
         }
</code></pre>
<h2 id="디버거를-사용하여-매-틱마다-일시정지-시키기"><a class="header" href="#디버거를-사용하여-매-틱마다-일시정지-시키기">디버거를 사용하여 매 틱마다 일시정지 시키기</a></h2>
<p><a href="game-of-life/../reference/debugging.html#using-a-debugger">브라우저의 스탭핑 디버거 (stepping debugger) 는 Rust로 작성한 WebAssembly와 상호작용하는 JavaScript 코드를 살펴볼 때 유용합니다.</a></p>
<p>예를 들어서, <code>universe.tick()</code> 호출 이전에 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger">JavaScript 코드에 <code>debugger;</code> 줄</a>을 추가하면 디버깅 툴을 사용하여 <code>renderLoop</code>의 매 순회마다 코드 실행을 일시정지시킬수 있게 됩니다.</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  debugger;
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>이제 로그 메세지를 쉽게 살펴볼 수 있도록 간편한 체크포인트(checkpoint) 기능을 사용할 수 있게 됐습니다. 이 기능을 통해 현재 렌더된 프레임과 이전 프레임을 비교할 수 있습니다.</p>
<p><a href="game-of-life/../images/game-of-life/debugging.png"><img src="game-of-life/../images/game-of-life/debugging.png" alt="Game of Life 디버깅 화면 스크린샷" /></a></p>
<h2 id="연습해-보기-3"><a class="header" href="#연습해-보기-3">연습해 보기</a></h2>
<ul>
<li>
<p>죽게 되거나 살아나게 되는 식으로 상태가 전환되는 각각 세포의 행과 열을 기록할 수 있도록 <code>tick</code> 함수를 로그 하는 코드를 추가해 보세요.</p>
</li>
<li>
<p><code>Universe::new</code> 메소드에 <code>panic!()</code> 매크로를 추가해서 웹 브라우저의 JavaScript 디버깅 툴에서 패닉한 코드를 <a href="https://ko.wikipedia.org/wiki/%ED%87%B4%EA%B0%81%EA%B2%80%EC%83%89">퇴각검색(backtrace)</a> 할 수 있도록 수정해 보세요. 추가로 debug 심볼을 비활성화한 다음 <code>console_error_panic_hook</code> 선택적 종속성을 다시 빌드했을 때 스택 추적도 다시 확인해 보세요. 그렇게 유용하진 않은 것 같은데, 안 그런가요?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="상호작용-추가하기"><a class="header" href="#상호작용-추가하기">상호작용 추가하기</a></h1>
<p>구현한 Game of Life에 상호작용을 조금 더 추가해 보면서 JavaScript와 WebAssembly 인터페이스를 조금 더 탐험해 보도록 하겠습니다. 이 섹션에서는 유저들이 세포를 클릭해서 생존 여부를 전환시킬수 있도록 해보고, 일시정지 기능도 구현해서 세포 패턴을 유저들이 손쉽게 그려볼 수 있도록 해볼 예정입니다.</p>
<h2 id="일시정지-버튼"><a class="header" href="#일시정지-버튼">일시정지 버튼</a></h2>
<p>게임을 일시정지 시킬 수 있도록 버튼을 하나 만들어 봅시다. <code>wasm-game-of-life/www/index.html</code> 파일 내의 <code>&lt;canvas&gt;</code> 바로 위에 이 버튼을 추가해주세요:</p>
<pre><code class="language-html">&lt;button id="play-pause"&gt;&lt;/button&gt;
</code></pre>
<p><code>wasm-game-of-life/www/index.js</code> JavaScript 파일에 다음 변경사항들을 적용해 보겠습니다:</p>
<ul>
<li>
<p>취소시키고 싶은 식별자를 <code>cancelAnimationFrame</code> 함수로 전달시킬 수 있도록 <code>requestAnimationFrame</code> 함수가 제일 마지막으로 반환한 식별자를 추적합니다.</p>
</li>
<li>
<p>재생/일시정지 버튼을 눌렀을 때, 대기 중인 애니메이션 프레임을 가리키는 식별자를 가지고 있는지 확인합니다. 이 식별자를 가지고 있는 시점에서는 게임이 실행 중일 것이므로 <code>renderLoop</code>가 다시 호출되지 않도록 애니메이션을 일시정지 시킵니다. 식별자를 가지고 있지 않다면 게임이 멈춰있다는 의미이므로 <code>requestAnimationFrame</code> 함수를 사용하여 게임을 다시 시작해주도록 합니다.</p>
</li>
</ul>
<p>이 작업은 JavaScript 환경에서 진행해야 하기 때문에 따로 Rust 소스 코드를 수정할 필요가 없습니다.</p>
<p><code>animationId</code> 변수를 추가하여 <code>requestAnimationFrame</code> 함수가 반환하는 식별자를 추적해 봅시다. 대기 중인 애니메이션이 없을 때는 이 값을 <code>null</code>로 설정해 주겠습니다.</p>
<pre><code class="language-js">let animationId = null;

// `requestAnimationFrame`의 반환값이 `animationId`에
// 할당된다는 점 외에는 기존과 동일한 함수입니다.
const renderLoop = () =&gt; {
  drawGrid();
  drawCells();

  universe.tick();

  animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>언제든 <code>animationId</code>의 값을 확인해서 게임이 멈춰있는지 확인할 수 있습니다:</p>
<pre><code class="language-js">const isPaused = () =&gt; {
  return animationId === null;
};
</code></pre>
<p>이제 재생/일시정지 버튼이 클릭 됐을 때 게임의 재생 여부를 확인할 수 있게 됐습니다. 마찬가지로 <code>renderLoop</code> 함수를 통해 애니메이션을 다시 시작하거나 일시정지 시킬수도 있습니다. 추가로, 버튼을 클릭했을 때 표시되는 텍스트의 아이콘을 업데이트해 주도록 하겠습니다.</p>
<pre><code class="language-js">const playPauseButton = document.getElementById("play-pause");

const play = () =&gt; {
  playPauseButton.textContent = "⏸";
  renderLoop();
};

const pause = () =&gt; {
  playPauseButton.textContent = "▶";
  cancelAnimationFrame(animationId);
  animationId = null;
};

playPauseButton.addEventListener("click", event =&gt; {
  if (isPaused()) {
    play();
  } else {
    pause();
  }
});
</code></pre>
<p>마지막으로, 추가한 버튼이 올바른 초기 텍스트 아이콘을 표시하도록 이전에 <code>requestAnimationFrame(renderLoop)</code>을 직접 불러서 빠르게 시작했던 부분을 <code>play</code> 함수를 대신 호출하도록 변경해 보겠습니다.</p>
<pre><code class="language-diff">// 기존에는 `requestAnimationFrame(renderLoop)`를 호출하는 줄이었습니다.
play();
</code></pre>
<p><a href="http://localhost:8080/">http://localhost:8080/</a> 페이지를 새로고침하면 일시정지/재생 버튼이 추가된 부분을 확인할 수 있습니다!</p>
<h2 id="onclick-이벤트로-세포-상태-전환하기"><a class="header" href="#onclick-이벤트로-세포-상태-전환하기"><code>onclick</code> 이벤트로 세포 상태 전환하기</a></h2>
<p>이제 게임을 일시정지 할 수 있게 됐으니 세포들을 클릭해서 상태를 바꿀 수 있도록 코드를 수정해 보겠습니다.</p>
<p>세포를 클릭할 때, 클릭한 세포의 생존 여부를 전환할 수 있도록 코드를 작성해 보겠습니다. <code>toggle</code> 메소드를 <code>wasm-game-of-life/src/lib.rs</code> 파일 내의 <code>Cell</code>에 추가해 줍시다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cell {
    fn toggle(&amp;mut self) {
        *self = match *self {
            Cell::Dead =&gt; Cell::Alive,
            Cell::Alive =&gt; Cell::Dead,
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>주어진 행과 열에 위치한 세포의 상태를 전환할 수 있도록, 행과 열을 벡터의 인덱스로 변환하고, 변환한 인덱스를 세포 벡터로 변환하겠습니다. 세포 벡터가 준비됐다면 변환된 인덱스에 위치하는 세포를 전환할 수 있도록 메소드를 호출해 봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public 메소드, JavaScript로 익스포트 할 수 있도록 함.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn toggle_cell(&amp;mut self, row: u32, column: u32) {
        let idx = self.get_index(row, column);
        self.cells[idx].toggle();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이 <code>impl</code> 블럭 내에 정의된 메소드에 <code>#[wasm_bindgen]</code> 속성을 추가하여 JavaScript 코드에서 호출할 수 있도록 했습니다.</p>
<p><code>wasm-game-of-life/www/index.js</code> 파일에서 <code>&lt;canvas&gt;</code> 요소의 클릭 이벤트를 수신(listening)해보겠습니다. 콜백 함수 내부에는 페이지의 상대 좌표를 캔버스 상대 좌표로 변환한 다음 <code>toggle_cell</code> 메소드를 호출하여 장면을 다시 그려볼수 있도록 코드를 작성해보겠습니다.</p>
<pre><code class="language-js">canvas.addEventListener("click", event =&gt; {
  const boundingRect = canvas.getBoundingClientRect();

  const scaleX = canvas.width / boundingRect.width;
  const scaleY = canvas.height / boundingRect.height;

  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
  const canvasTop = (event.clientY - boundingRect.top) * scaleY;

  const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);
  const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);

  universe.toggle_cell(row, col);

  drawGrid();
  drawCells();
});
</code></pre>
<p><code>wasm-game-of-life</code> 경로에서 <code>wasm-pack build</code> 명령어를 실행하여 다시 빌드한 다음, <a href="http://localhost:8080/">http://localhost:8080/</a> 페이지를 새로고침해 보세요. 이제 세포를 직접 클릭해서 상태를 전환할 수 있게 됐습니다. 패턴을 한번 그려보세요!</p>
<h2 id="연습해-보기-4"><a class="header" href="#연습해-보기-4">연습해 보기</a></h2>
<ul>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range"><code>&lt;input type="range"&gt;</code></a> 위젯을 추가하여 매 프레임마다 발생하는 틱의 수를 조절할 수 있도록 코드를 작성해 보세요.</p>
</li>
<li>
<p>세상을 랜덤한 초기 상태로 리셋할 수 있도록 버튼을 하나 더 추가해 보세요. 또 다른 버튼을 추가해서 모든 세포가 죽은 상태로 새로 시작할 수 있도록 구현해 봐도 좋습니다.</p>
</li>
<li>
<p>Ctrl을 누른 상태로 세포를 클릭하면 (<code>Ctrl + 클릭</code>) 클릭한 세포를 중심으로 <a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)">glider</a> 패턴이 추가되도록 코드를 작성해 보세요. Shift를 누른 상태로 클릭할 때는 (<code>Shift + Click</code>) pulsar 패턴을 그리도록 작성해 봐도 좋습니다.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="타임-프로파일링"><a class="header" href="#타임-프로파일링">타임 프로파일링</a></h1>
<p>이 챕터에서는 타임 <a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)">프로파일링</a> 작업을 해보면서 이전에 구현한 Game of Life의 성능을 개선시켜보겠습니다.</p>
<p>시작하기 전에, <a href="game-of-life/../reference/time-profiling.html">Rust와 WebAssembly 코드에 사용해 볼 수 있는 타임 프로파일링 툴들</a>을 살펴보셔도 좋습니다.</p>
<h2 id="windowperformancenow-함수를-사용하여-초당-프레임-fps-frames-per-second-타이머-만들기"><a class="header" href="#windowperformancenow-함수를-사용하여-초당-프레임-fps-frames-per-second-타이머-만들기"><code>window.performance.now</code> 함수를 사용하여 초당 프레임 (FPS, Frames Per Second) 타이머 만들기</a></h2>
<p>이 FPS 타이머는 구현한 게임의 렌더링 속도를 어떻게 개선시킬지 살펴볼 때 매우 유용하게 사용될 예정입니다.</p>
<p><code>wasm-game-of-life/www/index.js</code> 파일에 <code>fps</code> 객체를 추가하는 것으로 시작해 봅시다:</p>
<pre><code class="language-js">const fps = new class {
  constructor() {
    this.fps = document.getElementById("fps");
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // 마지막 프레임 렌더부터의 델타 시간을 fps 단위로 변환합니다.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = 1 / delta * 1000;

    // 마지막 100개의 타이밍만 저장합니다.
    this.frames.push(fps);
    if (this.frames.length &gt; 100) {
      this.frames.shift();
    }

    // 최대, 최소 타이밍과 마지막 100개 타이밍의 평균을 찾습니다.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i &lt; this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // 통계를 렌더합니다.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
};
</code></pre>
<p><code>fps</code> 객체의 <code>render</code> 함수를 <code>renderLoop</code> 함수의 매 반복마다 호출해 보겠습니다:</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
    fps.render(); //new

    universe.tick();
    drawGrid();
    drawCells();

    animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>마지막으로, <code>fps</code> 요소를 <code>wasm-game-of-life/www/index.html</code> 파일에 잊지 않고 추가해 줍시다. <code>&lt;canvas&gt;</code> 바로 위에 추가해 주세요:</p>
<pre><code class="language-html">&lt;div id="fps"&gt;&lt;/div&gt;
</code></pre>
<p>CSS 프로퍼티를 추가해서 깔끔하게 포맷해 주겠습니다:</p>
<pre><code class="language-css">#fps {
  white-space: pre;
  font-family: monospace;
}
</code></pre>
<p>짜잔! 이제 <a href="http://localhost:8080">http://localhost:8080</a> 페이지를 새로고침 하면 FPS 카운터를 확인할 수 있게 됐습니다!</p>
<h3 id="universetick의-매-틱을-consoletime-consoletimeend-를-사용하여-측정하기"><a class="header" href="#universetick의-매-틱을-consoletime-consoletimeend-를-사용하여-측정하기"><code>Universe::tick</code>의 매 틱을 <code>console.time</code>, <code>console.timeEnd</code> 를 사용하여 측정하기</a></h3>
<p><code>web-sys</code> 크레이트의 <code>console.time</code>, <code>console.timeend</code> 를 활용하여 각 <code>Universe::tick</code>이 호출되는데 걸리는 시간을 확인해 볼 수 있습니다.</p>
<p>먼저, <code>wasm-game-of-life/Cargo.toml</code> 파일을 열고 <code>web-sys</code> 를 종속성으로 추가해 주세요:</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = "0.3"
features = [
  "console",
]
</code></pre>
<p><code>console.time</code>를 호출할 때마다 <code>console.timeEnd</code>도 같이 호출될 예정이기 때문에, <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> 타입으로 묶어서 간편하게 사용 할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;
use web_sys::console;

pub struct Timer&lt;'a&gt; {
    name: &amp;'a str,
}

impl&lt;'a&gt; Timer&lt;'a&gt; {
    pub fn new(name: &amp;'a str) -&gt; Timer&lt;'a&gt; {
        console::time_with_label(name);
        Timer { name }
    }
}

impl&lt;'a&gt; Drop for Timer&lt;'a&gt; {
    fn drop(&amp;mut self) {
        console::time_end_with_label(self.name);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>그다음, 메소드 최상단에 다음 코드를 추가해서 각 <code>Universe::tick</code> 호출이 얼마나 오래 걸리는지 측정해 볼 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _timer = Timer::new("Universe::tick");
<span class="boring">}</span></code></pre></pre>
<p>콘솔에 <code>Universe::tick</code>를 호출하는 데 걸리는 시간을 로그로 표시합니다:</p>
<p><a href="game-of-life/../images/game-of-life/console-time.png"><img src="game-of-life/../images/game-of-life/console-time.png" alt="console.time 로그 스크린샷" /></a></p>
<p>추가로, 브라우저 프로파일러(profiler)의 timeline 혹은 waterfall 뷰에서 <code>console.time</code>과 <code>console.timeEnd</code>가 같이 실행된 부분을 확인할 수 있습니다:</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-profiler.png"><img src="game-of-life/../images/game-of-life/console-time-in-profiler.png" alt="console.time 로그 스크린샷" /></a></p>
<h2 id="game-of-life-세상의-사이즈-늘려보기"><a class="header" href="#game-of-life-세상의-사이즈-늘려보기">Game of Life 세상의 사이즈 늘려보기</a></h2>
<blockquote>
<p>⚠️ 이 섹션은 FireFox의 스크린샷을 예시로 보여줍니다. 거의 모든 모던 브라우저가 비슷한 기능들을 가지고 있지만, 브라우저마다 개발자 도구에 약간의 차이가 있을 수는 있습니다. 뜯어보게 될 프로파일 정보는 기본적으로 같지만, 보게 될 뷰나 도구 이름 등이 살짝 다를 수 있는 점을 미리 확인해 주세요.</p>
</blockquote>
<p>구현한 Game of Life 세상을 더 크게 만들어보면 어떨까요? 64 x 64 사이즈의 세상을 128 x 128 사이즈로 늘려봅시다. (<code>wasm-game-of-life/src/lib.rs</code> 파일에서 <code>Universe::new</code>를 수정해 주세요.) 제 컴퓨터에서는 사이즈를 늘렸을 때 부드럽게 작동하던 60fps 화면이 버벅이면서 40fps 처럼 보이는 부분이 확인됩니다.</p>
<p>프로파일을 기록하고 waterfall 뷰를 확인하면, 각 애니메이션이 처리되는데 20 밀리초보다 더 많이 걸리는 것을 확인할 수 있습니다. 60fps로 표시됐을 때는 프레임 전체를 렌더하는데 16 밀리초가 걸린 것을 떠올려보면 확실히 차이가 있는 것 같습니다. 참고로, JavaScript와 WebAssembly외에도 페이지를 그리는 등 브라우저가 수행하는 다른 작업의 영향도 있으니 참고해 주세요.</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-before-waterfall.png" alt="페이지 렌더링 처리의 waterfall 뷰 스크린샷" /></a></p>
<p>한 애니메이션 프레임 동안 어떤 일이 일어나는지 잘 확인해 보면, <code>CanvasRenderingContext2D.fillStyle</code>의 setter가 많은 성능을 요구하는 부분을 확인할 수 있습니다.</p>
<blockquote>
<p>⚠️ FireFox 브라우저에서 위 내용에서 언급된 <code>CanvasRenderingContext2D.fillStyle</code> 대신에 "DOM"이 표시된다면 성능 개발자 도구 (performance developer tools) 에서 "Gecko 플랫폼 데이터 표시하기 (Show Gecko Platform Data)" 옵션을 활성화해줘야 할수도 있습니다:</p>
<p><a href="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png"><img src="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png" alt="&quot;Gecko 플랫폼 데이터 표시하기 (Show Gecko Platform Data)&quot; 옵션 활성화하기" /></a></p>
</blockquote>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png" alt="페이지 렌더링 처리의 flamegraph 뷰 스크린샷" /></a></p>
<p>많은 프레임의 호출 트리 집계 (call tree's aggregation) 를 살펴보면 이게 전혀 이상한 동작이 아님을 확인할 수 있습니다:</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-calltree.png"><img src="game-of-life/../images/game-of-life/drawCells-before-calltree.png" alt="페이지 렌더링 처리의 flamegraph 뷰 스크린샷" /></a></p>
<p>어이쿠! 거의 40% 분량을 이 setter에 사용해버렸네요!</p>
<blockquote>
<p>⚡ <code>tick</code> 메소드가 성능 병목을 일으키는데 특별한 이유가 있을 것 같았지만, 사실 그렇지 않은 부분을 확인했습니다. 이렇게 작업을 하다 보면 예상치 못한 부분에서 시간을 많이 쓰게 될 수도 있으니, 항상 <strong>정말 중요한</strong> 프로파일링 도구를 먼저 살펴보도록 합시다.</p>
</blockquote>
<p><code>wasm-game-of-life/www/index.js</code> 파일 내의 <code>drawCells</code> 함수에서 <code>fillStyle</code> 프로퍼티가 한번 정해지면 세상 내의 모든 세포와 모든 애니메이션에 이 프로퍼티가 사용되게 됩니다.</p>
<pre><code class="language-js">for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD
      ? DEAD_COLOR
      : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p><code>fillStyle</code>가 많은 성능을 요구하는 부분을 확인했는데, 그렇다면 어떤 식으로 코드를 작성해서 개선시킬수 있을까요? 세포의 생존 여부에 따라 <code>fillStyle</code>를 사용하도록 바꿔봅시다. <code>fillStyle = ALIVE_COLOR</code>를 추가해 줘서 살아있는 세포만 그리도록 하고 <code>fillStyle = DEAD_COLOR</code>도 추가해 줘서 죽은 세포도 동일한 방식으로 처리를 해준다면 세포들을 모두 한 번에 그리는 대신 <code>fillStyle</code>을 두 번만 설정하게 됩니다.</p>
<pre><code class="language-js">// 살아있는 세포들을 처리합니다.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Alive) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// 죽어있는 세포들을 처리합니다.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Dead) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>코드 파일을 저장하고 <a href="http://localhost:8080/">http://localhost:8080/</a> 페이지를 새로고침 해주면, 웹사이트가 60fps로 다시 부드럽게 렌더 됩니다.</p>
<p>프로파일을 다시 확인해 보면, 각 애니메이션 프레임마다 오직 10 밀리초만 걸리는 부분도 확인할 수 있습니다.</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-after-waterfall.png" alt="drawCells 함수를 업데이트한 이후 페이지 렌더링 처리의 waterfall 뷰 스크린샷" /></a></p>
<p>한 프레임을 다시 분석해 보면, <code>fillStyle</code> 이 더 이상 성능을 많이 사용하지 않고, <code>fillRect</code>가 각 세포 사각형을 그리는데 대부분의 시간이 소비되는 것을 확인할 수 있습니다.</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png" alt="drawCells 함수를 업데이트한 이후 페이지 렌더링 처리의 flamegraph 뷰 스크린샷" /></a></p>
<h2 id="game-of-life가-더-빠르게-진행되도록-만들어보기"><a class="header" href="#game-of-life가-더-빠르게-진행되도록-만들어보기">Game of Life가 더 빠르게 진행되도록 만들어보기</a></h2>
<p>어떤 사람들은 빨리빨리 진행하는 것을 선호해서 매 프레임마다 1틱이 아니라 9틱씩 진행되도록 수정하고 싶을 수도 있습니다. 놀랍게도 이 작업은 <code>wasm-game-of-life/www/index.js</code> 파일의 <code>renderLoop</code> 함수를 수정해서 생각 외로 간단하게 해볼 수 있습니다:</p>
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  universe.tick();
}
</code></pre>
<p>제 컴퓨터에서 구현한 게임이 35fps 속도로 다시 느려진 것 같습니다. 좋지 않은 현상이니 다시 60fps 로 만들어보겠습니다!</p>
<p>잘 확인해보면 <code>Universe::tick</code> 에서 시간이 많이 소요되는 것으로 보입니다. <code>Timer</code>를 추가해서 <code>console.time</code>과 <code>console.timeEnd</code> 호출을 감싸고 다시 한번 살펴보겠습니다. 제 예상대로라면 매 틱마다 세포의 새 벡터를 할당하고 기존 벡터를 해제(freeing)하는 작업은 많은 성능을 사용할 뿐 아니라 시간도 많이 소비하게 될것 같습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tick(&amp;mut self) {
    let _timer = Timer::new("Universe::tick");

    let mut next = {
        let _timer = Timer::new("다음 세포들을 할당합니다.");
        self.cells.clone()
    };

    {
        let _timer = Timer::new("다음 세대를 처리합니다.");
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // 규칙 1: 인구 부족으로 2개 미만의 이웃을 가진 세포는 죽게 됩니다.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // 규칙 2: 2개 혹은 3개의 이웃을 가진 세포는 다음 세대에서 계속 살아있습니다.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // 규칙 3: 과잉 인구로 3개 초과의 이웃을 가진 모든 세포는 죽게 됩니다.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // 규칙 4: 세포 증식으로 정확히 3개의 이웃을 가진 세포는 살아나게 됩니다.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // 규칙이 적용되지 않는 세포들의 상태는 그대로 유지되게 됩니다.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new("기존 세포들을 해제합니다.");
    self.cells = next;
}
<span class="boring">}</span></code></pre></pre>
<p>브라우저 개발자 도구에서 타이밍(timing)을 잘 확인해 보면 이 예상이 사실은 명백하게 틀린 부분을 확인할 수 있습니다. 실제로는 대부분의 시간이 다음 세대 세포들을 계산하는데 사용되게 됩니다. 그리고 의외로 매 틱마다 벡터 값을 할당하고 해제하는 작업이 그렇게 성능을 많이 사용하지 않습니다. 다시 한번 <strong>정말 중요한</strong> 프로파일링을 해보겠습니다!</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-universe-tick.png"><img src="game-of-life/../images/game-of-life/console-time-in-universe-tick.png" alt="Universe::tick 타이머 결과 값의 스크린샷" /></a></p>
<p>사용하게 될 <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">테스트 기능 게이트 (test feature gate)</a> 가 <code>nightly</code> 버전에 같이 포함돼 있기 때문에, <code>nightly</code> 컴파일러가 필요합니다. 그러면 벤치마킹에 이 기능을 한번 사용해 보겠습니다. <a href="https://github.com/BurntSushi/cargo-benchcmp">cargo benchcmp</a>이라는 툴도 필요하니 설치해 주도록 합시다. 참고로 cargo benchcmp는 <code>cargo bench</code>로 생성한 마이크로 벤치마킹을 비교하는 데 사용하는 작은 사이즈의 유틸리티입니다.</p>
<p>WebAssembly와 동일한 작업을 수행하는 네이티브 코드인 <code>#[bench]</code>를 작성해 봅시다. 이렇게 네이티브 코드를 작성하게 되면 더 많은 기능을 사용할 수 있게 됩니다. 이제 새롭게 작성된 <code>wasm-game-of-life/benches/bench.rs</code>을 확인해 보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &amp;mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
<span class="boring">}</span></code></pre></pre>
<p><code>#[wasm_bindgen]</code> 속성을 모두 주석 처리 해주도록 하고, <code>Cargo.toml</code> 파일의 <code>"cdylib"</code>도 주석 처리 해주겠습니다. 이렇게 주석 처리를 하지 않으면 빌드가 실패하고 링크 오류(link errors)가 발생하게 됩니다.</p>
<p>준비가 다 됐다면, <code>cargo bench | tee before.txt</code> 명령어를 실행해서 코드를 컴파일하고 벤치마크를 실행해 보겠습니다. <code>| tee before.txt</code>를 포함하면서 <code>cargo bench</code> 명령어의 출력값을 가져와서 <code>before.txt</code> 파일에 저장할 예정이니 이 부분도 다시 확인해 주세요.</p>
<pre><code>$ cargo bench | tee before.txt
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>여기서 바이너리 파일의 경로도 같이 표시되는 부분을 확인할 수 있습니다. 이번에는 운영체제의 프로파일러를 사용하여 벤치마킹을 다시 한번 해보겠습니다. 저는 리눅스(Linux)를 사용하고 있으니 <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code></a>를 예제로 사용하겠습니다:</p>
<pre><code>$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<p><code>perf report</code> 명령어로 프로파일을 로드하면, 예상한 대로 대부분의 시간이 <code>Universe::tick</code>를 실행하는데 소비되는 것을 확인할 수 있습니다:</p>
<p><a href="game-of-life/../images/game-of-life/bench-perf-report.png"><img src="game-of-life/../images/game-of-life/bench-perf-report.png" alt="perf report 스크린샷" /></a></p>
<p><code>perf</code>를 실행한 다음 <code>a</code> 키를 누르면 어떤 어셈블리 명령어(instruction)이 함수를 처리할 때 사용되고 있는지 확인할 수 있습니다:</p>
<p><a href="game-of-life/../images/game-of-life/bench-perf-annotate.png"><img src="game-of-life/../images/game-of-life/bench-perf-annotate.png" alt="perf 화면에서 어셈블리 명령어를 표시하는 화면의 스크린샷" /></a></p>
<p>위 내용을 확인하면 26.67%의 시간이 이웃 세포들을 만들어내는 데 사용되고, 23.41%를 이웃들의 열 인덱스, 그리고 나머지 15.42%를 행 인덱스를 더하는 데 사용되는 것을 알 수 있습니다. 제일 많은 성능을 사용하는 세 명령어들 중, 두 번째와 세 번째로 비용이 많이 드는 명령어가 <code>div</code> 명령어인 부분도 확인할 수 있습니다. 이 <code>div</code> 구현들이 <code>Universe::live_neighbor_count</code> 함수에서 나머지 연산자로 인덱싱 하도록 구현했던 부분입니다. (modulo indexing logic)</p>
<p><code>wasm-game-of-life/src/lib.rs</code> 파일에서 <code>live_neighbor_count</code>를 정의했던 내용을 다시 떠올려봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
<span class="boring">}</span></code></pre></pre>
<p>코드를 다시 확인해 보면 <code>if</code> 블럭들로 첫째와 마지막 행과 열의 엣지 케이스(edge case) 를 처리하는데 코드를 불필요하게 길게 작성하는 대신 나머지 연산자 (modulo operator) 를 사용하고 있는 부분을 확인할 수 있습니다. <code>row</code>과 <code>column</code> 둘 다 세상의 가장자리에 있지 않고 나머지 연산자를 쓸 필요가 없는 일반적인 경우를 처리하는데도 <code>div</code> 명령어를 사용해서 많은 성능을 사용하는 부분도 확인됩니다. 반복문을 사용하는 대신에 <code>if</code> 문으로 이러한 엣지 케이스들을 처리하고, 여러 분기들을 CPU의 분기 예측기(branch predictor)가 예측하기 쉽도록 만들어보겠습니다.</p>
<p><code>live_neighbor_count</code>를 다음과 같이 다시 작성해 봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
<span class="boring">}</span></code></pre></pre>
<p>벤치마킹을 다시 해보겠습니다! 이번에는 출력되는 메세지들을 <code>after.txt</code>로 출력해 봅시다.</p>
<pre><code>$ cargo bench | tee after.txt
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>훨씬 나은 것 같습니다! <code>benchcmp</code> 툴과 방금 생성한 두 텍스트 파일을 확인해 보면 얼마나 나이졌는지 볼 수 있습니다:</p>
<pre><code>$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<p>우와! 7.61 배나 빨라졌네요!</p>
<p>WebAssembly는 의도적으로 일반적인 하드웨어 아키텍처와 밀접하게 매핑(mapping)되도록 설계돼 있지만, 이러한 네이티브 코드의 속도 향상이 WebAssembly 성능 향상으로도 이어질 수 있는지 확실히 확인해 보는 것도 중요합니다.</p>
<p><code>wasm-pack build</code> 명령어를 실행해서 <code>.wasm</code> 파일을 다시 빌드하고 <a href="http://localhost:8080/">http://localhost:8080/</a> 페이지를 새로고침 해주세요. 제 컴퓨터에서는 60 fps의 속도로 다시 작동하는 것이 확인됩니다. 브라우저의 프로파일러를 사용해서 다시 확인해 보니 각 애니메이션 프레임이 10 밀리초씩 걸리는 것으로 확인됩니다.</p>
<p>성공적으로 잘 마무리한 것 같습니다!</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png" alt="나머지 연산자를 if문 분기들로 바꾼 이후 페이지 렌더링 처리의 waterfall 뷰 스크린샷" /></a></p>
<h2 id="연습해-보기-5"><a class="header" href="#연습해-보기-5">연습해 보기</a></h2>
<ul>
<li>
<p>현재로는 할당과 해제를 처리하는 코드를 지우는 게 <code>Universe::tick</code> 속도를 향상시키는 가장 쉬운 방법입니다. <code>Universe</code>가 두 벡터만 관리하도록 하고, 두 벡터를 코드가 실행되는 내내 해제되거나 <code>tick</code> 함수에서 새 버퍼를 할당하지 않도록 세포들을 이중 버퍼링 (double buffering) 기법으로 구현해 보세요.</p>
</li>
<li>
<p>"Game of Life 구현하기" 섹션에서 델타 기반으로 설계한 내용을 토대로, Rust 코드가 상태가 바뀐 세포들의 목록을 반환하는 방식으로 다시 코드를 설계해 보세요. <code>&lt;canvas&gt;</code> 가 더 빨리 렌더되는 게 보이시나요? 매 틱마다 새 델타 목록을 할당하지 않으면서 구현하실수 있을것 같으신가요?</p>
</li>
<li>
<p>프로파일링 툴로 확인할 수 있듯, 2D <code>&lt;canvas&gt;</code> 렌더링이 특별히 빠르지는 않은 것 같습니다. 2D 캔버스 렌더러 대신 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> 렌더러를 대신 사용해서 코드를 다시 구현해 보세요. WebGL로 구현한 버전은 얼마나 더 빠른가요? 답답하게 느렸던 WebGL과 비교하면 얼마나 큰 사이즈의 세상을 가볍게 처리할 수 있게 됐나요?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-파일-사이즈-줄이기"><a class="header" href="#wasm-파일-사이즈-줄이기"><code>.wasm</code> 파일 사이즈 줄이기</a></h1>
<p>구현했던 Game of Life 프로그램과 같이 <code>.wasm</code> 형식으로 컴파일된 바이너리를 유저들에게 네트워크로 전송할 때 코드 사이즈를 신경 쓰는 편이 좋습니다. 대부분의 경우에는 <code>.wasm</code> 파일의 사이즈가 작을수록 페이지가 빨리 로드되고 유저 경험이 더 나아집니다.</p>
<h2 id="빌드-설정으로-wasm-바이너리-사이즈를-얼마나-줄일-수-있나요"><a class="header" href="#빌드-설정으로-wasm-바이너리-사이즈를-얼마나-줄일-수-있나요">빌드 설정으로 <code>.wasm</code> 바이너리 사이즈를 얼마나 줄일 수 있나요?</a></h2>
<p><a href="game-of-life/../reference/code-size.html#optimizing-builds-for-code-size"><code>wasm</code> 바이너리 사이즈를 줄일 때 어떤 빌드 설정을 수정해 볼 수 있는지 한번 살펴보세요.</a></p>
<p>(debug 심볼이 빠져있는) 기본 빌드 설정으로 Game of Life를 빌드하면 29,410 bytes 사이즈의 바이너리가 출력되게 됩니다:</p>
<pre><code>$ wc -c pkg/wasm_game_of_life_bg.wasm
29410 pkg/wasm_game_of_life_bg.wasm
</code></pre>
<p>LTO를 활성화한 다음 <code>opt-level = "z"</code>를 설정하고 <code>wasm-opt -Oz</code> 명령어를 실행해서 빌드하면 출력되는 <code>.wasm</code> 바이너리의 사이즈가 17,317 bytes 정도로 줄어드는 부분을 확인할 수 있습니다.</p>
<pre><code>$ wc -c pkg/wasm_game_of_life_bg.wasm
17317 pkg/wasm_game_of_life_bg.wasm
</code></pre>
<p>그다음에는 출력된 바이너리를 (거의 모든 HTTP 서버가 하는 대로) <code>gzip</code>를 사용하여 압축해 보는데, 정말 귀엽게도 바이너리 파일의 사이즈를 9,045 bytes까지 줄일 수 있게 됩니다!</p>
<pre><code>$ gzip -9 &lt; pkg/wasm_game_of_life_bg.wasm | wc -c
9045
</code></pre>
<h2 id="연습해-보기-6"><a class="header" href="#연습해-보기-6">연습해 보기</a></h2>
<ul>
<li>
<p><a href="game-of-life/../reference/code-size.html#use-the-wasm-snip-tool"><code>wasm-snip</code> 툴</a>을 사용해서 구현했던 Game of Life의 <code>.wasm</code> 바이너리에서 패닉 디버깅 함수를 제외시켜보세요. 파일의 사이즈가 얼마나 줄어드나요?</p>
</li>
<li>
<p><a href="https://github.com/rustwasm/wee_alloc"><code>wee_alloc</code> 를 전역 할당자 (global allocator)</a>를 사용해 보고 파일의 사이즈를 이전과 비교해 보세요. 프로젝트를 시작할 때 클론 했던 <code>rustwasm/wasm-pack-template</code> 템플릿은 "wee_alloc" 이라는 cargo 기능을 포함하고 있는데, 이 기능은 <code>wasm-game-of-life/Cargo.toml</code> 파일에 있는 <code>[features]</code> 섹션의 <code>default</code> 필드에 추가해서 활성화할 수 있습니다.</p>
<pre><code class="language-toml">[features]
default = ["wee_alloc"]
</code></pre>
<p><code>wee_alloc</code>을 활성화하면 <code>.wasm</code> 바이너리 사이즈가 얼마나 줄어드나요?</p>
</li>
<li>
<p>튜토리얼을 진행하는 내내 한 <code>Universe</code>만 페이지에 포함시켰는데, 생성자를 사용하는 대신 단 한 개의 <code>static mut</code> 전역 인스턴스 (global instance) 만 수정하는 코드를 익스포트 해볼 수도 있습니다. 이전 챕터에서 다룬 이중 버퍼링 기법 (double buffering technique) 을 사용하고 싶다면, 이러한 버퍼도 <code>static mut</code> 키워드를 사용하여 전역적으로 만들어볼 수 있습니다. 이런 방식으로, 구현한 게임에서 모든 동적 할당 (dynamic allocation) 을 없앨 수 있고, <code>#![no_std]</code> 속성을 추가하여 할당기(allocator)가 없는 크레이트를 만들어볼 수도 있습니다. 동적 할당에 필요한 종속성을 다 없애면 <code>.wasm</code> 파일의 사이즈가 얼마나 줄어드나요?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="npm에-배포하기"><a class="header" href="#npm에-배포하기">npm에 배포하기</a></h1>
<p>사이즈가 작고 빠르게 작동하는 <code>wasm-game-of-life</code> 패키지가 준비됐습니다. 이제 다른 JavaScript 개발자들이 Game of Life 코드를 바로 종속성으로 받아 사용해 볼 수 있도록 npm에 배포해 보겠습니다.</p>
<h2 id="준비-사항"><a class="header" href="#준비-사항">준비 사항</a></h2>
<p>우선, <a href="https://www.npmjs.com/signup">기존에 생성된 npm 계정이 있는지 확인해주세요</a>.</p>
<p>그 다음, 다음 명령어를 실행하여 로컬 머신에서 계정에 로그인되어 있는지 확인해 주세요:</p>
<pre><code>wasm-pack login
</code></pre>
<h2 id="배포"><a class="header" href="#배포">배포</a></h2>
<p><code>wasm-game-of-life</code> 경로에서 <code>wasm-pack</code> 명령어를 실행하여 <code>wasm-game-of-life/pkg</code> 경로에 작성한 코드가 잘 빌드돼 있는지 확인해 주세요:</p>
<pre><code>wasm-pack build
</code></pre>
<p><code>wasm-game-of-life/pkg</code> 폴더의 내용물들을 한번 살펴보겠습니다. 이 폴더에 있는 파일들을 이제 npm에 배포해 볼 예정입니다!</p>
<p>준비가 됐다면, <code>wasm-pack publish</code> 를 실행해서 패키지를 npm에 업로드해보세요:</p>
<pre><code>wasm-pack publish
</code></pre>
<p>정말 놀랍게도 이게 답니다! 이렇게 npm에 패키지를 업로드할 수 있는데...</p>
<p>... 이 튜토리얼을 끝낸 다른 사람들도 npm에 배포를 했을 가능성이 높습니다. 그렇기 때문에 <code>wasm-game-of-life</code> 라는 패키지 이름이 높은 확률로 이미 사용 중일 수도 있습니다. 마지막으로 실행한 명령어가 이러한 이유로 성공적으로 실행되지 못한 부분이 확인되나요?</p>
<p><code>wasm-game-of-life/Cargo.toml</code> 파일을 열고 작성한 패키지가 고유한 이름을 가질 수 있도록 <code>name</code> 필드에 원하는 유저 이름을 추가해 주세요.</p>
<pre><code class="language-toml">[package]
name = "wasm-game-of-life-my-username"
</code></pre>
<p>이제 다시 빌드하고 배포해 보겠습니다:</p>
<pre><code>wasm-pack build
wasm-pack publish
</code></pre>
<p>이번에는 잘 배포됐을 겁니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="참조"><a class="header" href="#참조">참조</a></h1>
<p>이 섹션은 Rust와 WebAssembly 개발에 도움이 되는 참조 자료를 포함하고 있습니다.  순서가 정해져 있지 않아 처음부터 끝까지 읽을 필요가 없습니다. 각 하위 섹션은 개별적으로 각자 다른 내용을 다룹니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="알면-좋은-크레이트들"><a class="header" href="#알면-좋은-크레이트들">알면 좋은 크레이트들</a></h1>
<p>Rust와 WebAssembly로 개발할 때 알면 좋은 크레이트들을 모아놓은 목록입니다.</p>
<p><a href="https://crates.io/categories/wasm">creates.io 웹사이트에서 WebAssembly 카테고리로 등록된 크레이트들을 필터링해서 볼수도 있습니다.</a></p>
<h2 id="javascript와-dom-조작하기"><a class="header" href="#javascript와-dom-조작하기">JavaScript와 DOM 조작하기</a></h2>
<h3 id="wasm-bindgen--cratesio--레포지토리"><a class="header" href="#wasm-bindgen--cratesio--레포지토리"><code>wasm-bindgen</code> | <a href="https://crates.io/crates/wasm-bindgen">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen">레포지토리</a></a></h3>
<p><code>wasm-bindgen</code>은 Rust와 JavaScript 사이의 고레벨 상호작용을 도와주는 크레이트입니다. JavaScript와 Rust를 넘나들면서 임포트를 할 수 있도록 도와줍니다.</p>
<h3 id="wasm-bindgen-futures--cratesio--레포지토리"><a class="header" href="#wasm-bindgen-futures--cratesio--레포지토리"><code>wasm-bindgen-futures</code> | <a href="https://crates.io/crates/wasm-bindgen-futures">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/futures">레포지토리</a></a></h3>
<p><code>wasm-bindgen-futures</code>는 JavaScript의 <code>Promise</code>와 Rust의 <code>Future</code>을 연결해 주는 다리 역할을 하는 크레이트입니다. Rust와 JavaScript 사이에서 양방향으로 변환이 가능하고 Rust에서 비동기(asynchronous) 작업을 수행할 때 유용합니다. DOM 이벤트 및 I/O 작업과 상호작용할 수 있도록 해줍니다.</p>
<h3 id="js-sys--cratesio--레포지토리"><a class="header" href="#js-sys--cratesio--레포지토리"><code>js-sys</code> | <a href="https://crates.io/crates/js-sys">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys">레포지토리</a></a></h3>
<p><code>wasm-bindgen</code>으로 작성된 <code>js-sys</code> 크레이트는 <code>Object</code>, <code>Function</code>, <code>eval</code> 등의 JavaScript 전역 타입과 메소드를 모두 임포트합니다. 이러한 API들은 웹 뿐만 아니라 Node.js를 포함한 다른 모든 ECMAScript 환경에 이식해서 사용할 수 있습니다.</p>
<h3 id="web-sys--cratesio--레포지토리"><a class="header" href="#web-sys--cratesio--레포지토리"><code>web-sys</code> | <a href="https://crates.io/crates/web-sys">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys">레포지토리</a></a></h3>
<p>DOM 조작, <code>setTimeout</code>, Web GL, Web Audio 등과 같은 다른 모든 웹 API들을 <code>wasm-bindgen</code>으로 작성한 크레이트입니다.</p>
<h2 id="오류-보고-및-로깅"><a class="header" href="#오류-보고-및-로깅">오류 보고 및 로깅</a></h2>
<h3 id="console_error_panic_hook--cratesio--레포지토리"><a class="header" href="#console_error_panic_hook--cratesio--레포지토리"><code>console_error_panic_hook</code> | <a href="https://crates.io/crates/console_error_panic_hook">crates.io</a> | <a href="https://github.com/rustwasm/console_error_panic_hook">레포지토리</a></a></h3>
<p><code>console.error</code>로 메세지를 패닉 메세지를 넘겨주는 패닉 훅 (panic hook) 과 함께, <code>wasm32-unknown-unknown</code> 타겟으로 패닉들을 디버깅할 수 있도록 도와주는 크레이트입니다.</p>
<h3 id="console_log--cratesio--레포지토리"><a class="header" href="#console_log--cratesio--레포지토리"><code>console_log</code> | <a href="https://crates.io/crates/console_log">crates.io</a> | <a href="https://github.com/iamcodemaker/console_log">레포지토리</a></a></h3>
<p><a href="https://crates.io/crates/log"><code>log</code> 크레이트</a>의 백엔드를 제공해 주는 크레이트입니다. 로그 된 메세지들을 개발자 도구(devtools) 콘솔로 넘겨줍니다.</p>
<h2 id="동적-할당"><a class="header" href="#동적-할당">동적 할당</a></h2>
<h3 id="wee_alloc--cratesio--레포지토리"><a class="header" href="#wee_alloc--cratesio--레포지토리"><code>wee_alloc</code> | <a href="https://crates.io/crates/wee_alloc">crates.io</a> | <a href="https://github.com/rustwasm/wee_alloc">레포지토리</a></a></h3>
<p>이 크레이트의 이름은 <strong>W</strong>asm-<strong>E</strong>nabled, <strong>E</strong>lfin Allocator 에서 유래됐는데, (1000 bytes 이하 사이즈의 압축되지 않은 <code>.wasm</code> 바이너리로 구성된) 코드 사이즈가 할당 성능보다 더 중요할 때 유용하게 사용할 수 있도록 할당자를 구현한 코드입니다.</p>
<h2 id="wasm-바이너리를-파싱parsing하고-생성하기"><a class="header" href="#wasm-바이너리를-파싱parsing하고-생성하기"><code>.wasm</code> 바이너리를 파싱(parsing)하고 생성하기</a></h2>
<h3 id="parity-wasm--cratesio--레포지토리"><a class="header" href="#parity-wasm--cratesio--레포지토리"><code>parity-wasm</code> | <a href="https://crates.io/crates/parity-wasm">crates.io</a> | <a href="https://github.com/paritytech/parity-wasm">레포지토리</a></a></h3>
<p>직렬화(serializing)과 역직렬화(deserializing), 그리고 <code>.wasm</code> 바이너리를 빌드하는데 사용하는 저레벨 WebAssembly 포맷입니다. "names" 및 "reloc.WHATEVER"과 같이 잘 알려진 섹션들이 잘 지원돼 있습니다.</p>
<h3 id="wasmparser--cratesio--레포지토리"><a class="header" href="#wasmparser--cratesio--레포지토리"><code>wasmparser</code> | <a href="https://crates.io/crates/wasmparser">crates.io</a> | <a href="https://github.com/yurydelendik/wasmparser.rs">레포지토리</a></a></h3>
<p>WebAssembly 바이너리 파일을 읽는 데 사용하는 간단한 이벤트 기반 (event-driven)  라이브러리입니다. 각각 파싱한 내용의 바이트 오프셋 (byte offset) 을 제공하는데, 예를 들어 reloc을 읽는 작업 등에 필요합니다.</p>
<h2 id="webassembly-컴파일하고-인터프리팅interpreting하기"><a class="header" href="#webassembly-컴파일하고-인터프리팅interpreting하기">WebAssembly 컴파일하고 인터프리팅(Interpreting)하기</a></h2>
<h3 id="wasmi--cratesio--레포지토리"><a class="header" href="#wasmi--cratesio--레포지토리"><code>wasmi</code> | <a href="https://crates.io/crates/wasmi">crates.io</a> | <a href="https://github.com/paritytech/wasmi">레포지토리</a></a></h3>
<p>Parity 라는 회사에서 만든 임베딩 할 수 있는 WebAssembly 인터프리터입니다.</p>
<h3 id="cranelift-wasm--cratesio--레포지토리"><a class="header" href="#cranelift-wasm--cratesio--레포지토리"><code>cranelift-wasm</code> | <a href="https://crates.io/crates/cranelift-wasm">crates.io</a> | <a href="https://github.com/bytecodealliance/wasmtime/tree/master/cranelift">레포지토리</a></a></h3>
<p>WebAssembly 코드를 네이티브 호스트의 기계어(machine code)로 컴파일해 주는 크레이트인 Cranelift (né Cretonne) 코드 생성기 프로젝트의 일부입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="알면-좋은-툴들"><a class="header" href="#알면-좋은-툴들">알면 좋은 툴들</a></h1>
<p>Rust와 WebAssembly로 개발할 때 알면 좋은 툴들을 모아놓은 목록입니다.</p>
<h2 id="개발-빌드-및-워크플로우-관리-orchestration"><a class="header" href="#개발-빌드-및-워크플로우-관리-orchestration">개발, 빌드 및 워크플로우 관리 (Orchestration)</a></h2>
<h3 id="wasm-pack--레포지토리"><a class="header" href="#wasm-pack--레포지토리"><code>wasm-pack</code> | <a href="https://github.com/rustwasm/wasm-pack">레포지토리</a></a></h3>
<p><code>wasm-pack</code>은 Web과 Node.js 환경에서 JavaScript와 상호 운용하면서 Rust로 WebAssembly 작업을 할 때 사용할 수 있는 만능 툴입니다. <code>wasm-pack</code>을 사용해서 더 쉽게 WebAssembly를 빌드하고 npm 레지스트리에 배포하고, 기존에 이미 사용하는 워크플로우가 사용하는 패키지들과 같이 사용할 수 있도록 도와줍니다.</p>
<h2 id="wasm-바이너리-최적화와-조작하기"><a class="header" href="#wasm-바이너리-최적화와-조작하기"><code>.wasm</code> 바이너리 최적화와 조작하기</a></h2>
<h3 id="wasm-opt--레포지토리"><a class="header" href="#wasm-opt--레포지토리"><code>wasm-opt</code> | <a href="https://github.com/WebAssembly/binaryen">레포지토리</a></a></h3>
<p><code>wasm-opt</code>는 WebAssembly을 입력으로 받고 변형하고 최적화한 다음, 원한다면 코드를 측정/분석까지 한 다음 WebAssembly 파일을 출력합니다. <code>rustc</code>가 작동하는 방식처럼, LLVM으로 생성한 <code>.wasm</code> 바이너리를 입력으로 넣고 <code>wasm-opt</code>를 실행하면 더 작고 더 빠르게 실행할 수 있는 <code>.wasm</code> 바이너리 파일을 생성할 수 있습니다.</p>
<h3 id="wasm2js--레포지토리"><a class="header" href="#wasm2js--레포지토리"><code>wasm2js</code> | <a href="https://github.com/WebAssembly/binaryen">레포지토리</a></a></h3>
<p><code>wasm2js</code> 툴은 WebAssembly 파일을 "거의 asm.js"처럼 컴파일 해줍니다. Internet Explorer 11처럼 WebAssembly 기능이 구현되지 않은 브라우저를 지원할 때 좋습니다. 이 툴은 <code>binaryen</code> 프로젝트의 일부입니다.</p>
<h3 id="wasm-gc--레포지토리"><a class="header" href="#wasm-gc--레포지토리"><code>wasm-gc</code> | <a href="https://github.com/alexcrichton/wasm-gc">레포지토리</a></a></h3>
<p>WebAssembly를 가비지 콜렉팅하고 필요하지 않은 익스포트, 임포트, 함수 등을 지울 때 사용 수 있는 심플한 툴입니다. WebAssembly 파일과 함께 <code>--gc-sections</code> 링커 플래그 (linker flag) 를 사용하면 더 효과적입니다.</p>
<p>보통은 다음과 같은 이유로 이 툴을 개발자가 "직접" 프로젝트에 포함시키지 않습니다:</p>
<ol>
<li><code>rustc</code> 컴파일러가 이제 새 버전의 <code>lid</code>를 지원하는데, 이 버전이 <code>--gc-sections</code> 라는 플래그를 지원합니다. 이 플래그는 LTO 빌드를 하는데 자동으로 활성화되게 됩니다.</li>
<li><code>wasm-bindgen</code> CLI (커맨드 라인 인터페이스 / Command Line Interface) 툴이 자동으로 <code>wasm-gc</code> 를 실행시켜 줍니다.</li>
</ol>
<h3 id="wasm-snip--레포지토리"><a class="header" href="#wasm-snip--레포지토리"><code>wasm-snip</code> | <a href="https://github.com/rustwasm/wasm-snip">레포지토리</a></a></h3>
<p><code>wasm-snip</code>는 WebAssembly 함수의 내용을 <code>unreachable</code> 명령어(instruction)으로 바꿔줍니다.</p>
<p>어떤 함수가 실제로 호출되지 않는걸 아는데 컴파일러가 이걸 모를 때가 있나요? 일단 컴파일하고 <code>wasm-gc</code>를 실행해 보세요! (런타임(runtime)에서 호출되지 않는) 다른 간접적으로 호출되는 다른 함수들도 모두 제거됩니다.</p>
<p>디버깅 코드가 없는 실제로 배포하는 빌드 (production build) 에서 강제로 Rust 의 패닉 인프라(infrastructure)를 제외할 때 유용합니다.</p>
<h2 id="wasm-바이너리-살펴보기"><a class="header" href="#wasm-바이너리-살펴보기"><code>.wasm</code> 바이너리 살펴보기</a></h2>
<h3 id="twiggy--레포지토리"><a class="header" href="#twiggy--레포지토리"><code>twiggy</code> | <a href="https://github.com/rustwasm/twiggy">레포지토리</a></a></h3>
<p><code>twiggy</code>는 <code>.wasm</code> 바이너리에 사용하는 코드 프로파일러입니다. 바이너리의 호출 그래프 (call graph) 를 분석하고 다음과 같은 내용을 알려줍니다:</p>
<ul>
<li>
<p>애초에 빌드할 때 어떤 함수가 왜 바이너리에 포함됐나요? 예: 어떤 익스포트한 함수들이 간접적으로 호출되고 있나요?</p>
</li>
<li>
<p>어떤 함수를 지우면 얼마나 공간을 아낄 수 있나요? 예: 이 함수와 다른 사용되던 함수들까지 지우면 얼마나 공간이 절약되나요?</p>
</li>
</ul>
<p><code>twiggy</code>를 사용해서 바이너리를 더 가볍게 만들어보세요!</p>
<h3 id="wasm-objdump--레포지토리"><a class="header" href="#wasm-objdump--레포지토리"><code>wasm-objdump</code> | <a href="https://github.com/WebAssembly/wabt">레포지토리</a></a></h3>
<p><code>wasm</code> 바이너리의 저레벨 상세 정보와 섹션들을 출력합니다. WAT 텍스트 포맷으로 디어셈블링(disassembling)할 수도 있습니다. WebAssembly에 사용하는 <code>objdump</code>으로 생각해도 좋습니다. 이 툴은 WABT 프로젝트의 일부입니다.</p>
<h3 id="wasm-nm--레포지토리"><a class="header" href="#wasm-nm--레포지토리"><code>wasm-nm</code> | <a href="https://github.com/fitzgen/wasm-nm">레포지토리</a></a></h3>
<p><code>.wasm</code> 바이너리 내의 임포트되고, 익스포트되고, 그리고 private인 함수 심볼들 (function symbols) 을 나열합니다. WebAssembly에 사용하는 <code>nm</code>으로 생각해도 좋습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로젝트-템플릿"><a class="header" href="#프로젝트-템플릿">프로젝트 템플릿</a></h1>
<p>"The Rust and WebAssembly Working Group"은 개발자들이 빠르게 새 프로젝트를 시작하고 실행할 수 있도록 여러 가지 프로젝트 템플릿 목록을 만들고 관리합니다.</p>
<h2 id="wasm-pack-template"><a class="header" href="#wasm-pack-template"><code>wasm-pack-template</code></a></h2>
<p><a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a>으로 셋업 된 <a href="https://github.com/rustwasm/wasm-pack-template">이 템플릿</a>은 Rust와 WebAssembly 프로젝트를 손쉽게 시작할 수 있도록 준비돼 있습니다.</p>
<p><code>cargo generate</code> 명령어를 실행하여 프로젝트 템플릿을 클론해보세요:</p>
<pre><code>cargo install cargo-generate
cargo generate --git https://github.com/rustwasm/wasm-pack-template.git
</code></pre>
<h2 id="create-wasm-app"><a class="header" href="#create-wasm-app"><code>create-wasm-app</code></a></h2>
<p><a href="https://github.com/rustwasm/create-wasm-app">이 템플릿</a>은 <a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a>을 통해 배포된 npm 패키지를 간편하게 사용할 때 유용한 기능들을 포함합니다.</p>
<p><code>npm init</code> 명령어로 사용해 보세요:</p>
<pre><code>mkdir my-project
cd my-project/
npm init wasm-app
</code></pre>
<p>이 템플릿은 주로 <code>wasm-pack-template</code>이라는 종속성괴 함께 사용되는데, <code>create-wasm-app</code>으로 프로젝트를 생성하면 <code>npm link</code> 기능으로 생성한 프로젝트와 연결하는 데 사용됩니다.</p>
<h2 id="rust-webpack-template"><a class="header" href="#rust-webpack-template"><code>rust-webpack-template</code></a></h2>
<p><a href="https://github.com/rustwasm/rust-webpack-template">이 템플릿</a>은 Rust 코드를 WebAssembly로 컴파일하고 출력된 파일들을 Webpack의 <a href="https://github.com/wasm-tool/rust-loader/"><code>rust-loader</code></a>를 사용해서 바로 파이프라인으로 후킹 하여 연결할 수 있도록 거의 모든 보일러플레이트들을 대신 설정해 줍니다.</p>
<p><code>npm init</code> 명령어로 사용해 보세요:</p>
<pre><code>mkdir my-project
cd my-project/
npm init rust-webpack
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust로-생성한-webassembly-디버깅하기"><a class="header" href="#rust로-생성한-webassembly-디버깅하기">Rust로 생성한 WebAssembly 디버깅하기</a></h1>
<p>이 섹션은 Rust로 생성한 WebAssembly를 디버깅하는데 유용한 정보를 포함합니다.</p>
<h2 id="debug-심볼을-포함해서-빌드하기"><a class="header" href="#debug-심볼을-포함해서-빌드하기">debug 심볼을 포함해서 빌드하기</a></h2>
<blockquote>
<p>⚡ 디버깅할 때 항상 debug 심볼을 포함하고 빌드하는지 확인해 주세요!</p>
</blockquote>
<p>debug 심볼이 활성화 되어있지 않다면 <code>"name"</code> 커스텀 섹션이 컴파일된 <code>.wasm</code> 파일에 반영되지 않을 수도 있습니다. 이런 경우에는 <a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D_%EC%B6%94%EC%A0%81">스택 추적 (stack trace)</a> 을 할 때 함수 이름이 Rust 함수 이름 대신 <code>wasm-function[42]</code> 처럼 읽기 어렵게 표시됩니다. 정상적으로 이 심볼이 활성화 된 경우에는 <code>wasm_game_of_life::Universe::live_neighbor_count</code> 와 같이 표시됩니다.</p>
<p>(<code>wasm-pack build --debug</code> 혹은 <code>cargo build</code> 명령어로) "debug" 빌드를 할 경우 이 심볼이 기본값으로 활성화됩니다.</p>
<p>"release" 빌드를 할 때는 debug 심볼이 기본값으로 활성화되지 않으니 참고해주세요. 그래도 활성화를 하고 싶다면 <code>Cargo.toml</code> 파일을 열고 <code>[profile.release]</code> 섹션에 <code>debug = true</code>를 포함시켜주세요.</p>
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<h2 id="console-api로-로깅-하기"><a class="header" href="#console-api로-로깅-하기"><code>console</code> API로 로깅 하기</a></h2>
<p>로깅(logging) 작업은 코드를 설계하면서 만든 가설들을 확인하고 프로그램의 버그를 잡아내는 데 매우 효과적입니다. 보통은 웹 환경에서 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log"><code>console.log</code>
함수</a>를 호출하여 브라우저의 개발자 콘솔에 메세지를 로그할 수 있습니다.</p>
<p>하지만 <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html"><code>web-sys</code> 크레이트</a>를 사용하여 <code>console</code> 로깅 함수를 해볼수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

web_sys::console::log_1(&amp;"Hello, world!".into());
<span class="boring">}</span></code></pre></pre>
<p>또 다른 옵션으로는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/error"><code>console.error</code> 함수</a>가 있습니다. <code>console.error</code>는 <code>console.log</code>와 같은 타입 시그니처(signature)를 포함하고 있지만 개발자 툴에서 로그 메세지와 함께 스택 추적을 찾고 표시하는 데 사용할 수 있습니다.</p>
<h3 id="참조-1"><a class="header" href="#참조-1">참조</a></h3>
<ul>
<li>
<p><code>web-sys</code> 크레이트로 <code>console.log</code> 함수 사용하기:</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html">로그할 값들을 배열로 받는 <code>web_sys::console::log</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html">한 값만 로그 하는 <code>web_sys::console::log_1</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html">두 값을 로그 하는 <code>web_sys::console::log_2</code></a></li>
<li>기타...</li>
</ul>
</li>
<li>
<p><code>web-sys</code> 크레이트로 <code>console.error</code> 함수 사용하기:</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html">로그할 값들을 배열로 받는 <code>web_sys::console::error</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html">한 값만 로그하는 <code>web_sys::console::error_1</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html">두 값을 로그하는 <code>web_sys::console::error_2</code></a></li>
<li>기타...</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console"><code>console</code> 객체에 대해 설명해 주는 MDN 문서</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Tools/Web_Console">Firefox 개발자 도구 — 웹 콘솔</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/console">Microsoft Edge 개발자 도구 — 콘솔</a></p>
</li>
<li>
<p><a href="https://developers.google.com/web/tools/chrome-devtools/console/get-started">Console Chrome DevTools 콘솔을 사용하여 시작해 보기</a></p>
</li>
</ul>
<h2 id="패닉-로그-하기"><a class="header" href="#패닉-로그-하기">패닉 로그 하기</a></h2>
<p><a href="https://github.com/rustwasm/console_error_panic_hook"><code>console_error_panic_hook</code> 크레이트는 <code>console.error</code> 함수를 사용하여 예상치 못한 패닉들을 로그 합니다.</a> 이 크레이트를 통해 외계어같이 보이고 디버깅하기 어려운 <code>RuntimeError: unreachable executed</code> 에러 메세지 대신 Rust 환경에서 로그 했던 것과 같이 깔끔하게 포맷된 패닉 메세지를 표시할 수 있습니다.</p>
<p>정말 간단하게도 코드가 시작되는 함수에서 <code>console_error_panic_hook::set_once()</code>를 호출해서 훅(hook)을 설정하기만 하면 됩니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="디버거-사용하기"><a class="header" href="#디버거-사용하기">디버거 사용하기</a></h2>
<p>정말 아쉽게도 WebAssembly 디버깅 경험은 아직 개선돼야할 부분이 많습니다. 대부분의 Unix 시스템에서는 <a href="http://dwarfstd.org/">DWARF</a>를 사용하여 소스 레벨에서 실행하는 프로그램을 살펴보게 되는데, 이 DWARF를 사용하여 디버거가 필요로 하는 정보를 인코딩(encoding)할 수 있습니다. 반면에 Windows에서는 대신 사용할 수 있는 포맷이 있음에도 현재로서는 WebAssembly를 직접적으로 지원하지는 않습니다. 그러므로 따로 작성했던 Rust 소스 텍스트 대신 컴파일러가 출력한 WebAssembly 명령어를 그대로 확인해야 합니다.</p>
<blockquote>
<p><a href="https://github.com/WebAssembly/debugging">W3C WebAssembly group의 디버깅 하위 조항</a>도 있으므로 미래에는 이런 문제가 개선될 것으로 예상됩니다!</p>
</blockquote>
<p>그래도 WebAssembly와 함께 작성된 JavaScript 코드를 살펴보고 wasm의 상태를 직접 살펴보는데 디버거가 매우 유용하므로 참고해 주세요.</p>
<h3 id="참조-2"><a class="header" href="#참조-2">참조</a></h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger">Firefox 개발자 도구 — 디버거</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/debugger">Microsoft Edge 개발자 도구 — 디버거</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/">Chrome DevTools에서 JavaScript 디버깅 시작해보기</a></li>
</ul>
<h2 id="처음부터-webassembly-디버깅을-최소화할-수-있도록-신경-써서-코드를-작성해-주세요"><a class="header" href="#처음부터-webassembly-디버깅을-최소화할-수-있도록-신경-써서-코드를-작성해-주세요">처음부터 WebAssembly 디버깅을 최소화할 수 있도록 신경 써서 코드를 작성해 주세요</a></h2>
<p>고쳐야 할 버그가 JavaScript나 Web API 환경을 필요로 한다면 <a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html"><code>wasm-bindgen-test</code>으로 테스팅 코드를 작성해 보세요</a>.</p>
<p>그렇지 <em>않다면</em> <code>#[test]</code> 속성을 포함하여 일반적인 Rust 코드처럼 실행 환경을 재현해 보세요. 이런 방식으로 운영체제의 성숙한 네이티브 툴링을 최대한 활용하여 디버깅할 수 있게 됩니다. <a href="https://crates.io/crates/quickcheck"><code>quickcheck</code></a>과 같은 테스팅 크레이트와 테스팅 코드 축소기도  보면서 기계적으로 테스트 코드의 사이즈를 줄여볼수도 있습니다. 최종적으로는, JavaScript 환경이 요구되지 않도록 더 작은 Rust 테스트 코드로 분리시키는 식으로 버그를 더 쉽게 찾고 고칠 수 있게 됩니다.</p>
<p>컴파일러와 링커(linker) 오류 없이 네이티브 <code>#[test]</code> 속성을 사용하려면 <code>Cargo.toml</code> 파일의 <code>[lib.crate-type]</code> 배열에 <code>rlib</code>가 포함돼 있는지 확인해 주세요.</p>
<pre><code class="language-toml">[lib]
crate-type ["cdylib", "rlib"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="타임-프로파일링-1"><a class="header" href="#타임-프로파일링-1">타임 프로파일링</a></h1>
<p>이 섹션은 Rust와 WebAssembly을 사용하여 성능을 덜 쓰면서도 지연 시간도 줄일 수 있도록 페이지를 프로파일링하는 방법에 대해 다룹니다.</p>
<blockquote>
<p>⚡ 프로파일링을 할 때에는 항상 최적화된 빌드를 사용해주세요! <code>wasm-pack build</code> 명령어를 사용하고 있다면 이러한 최적화 옵션이 기본적으로 활성화돼있으니 참고해  주세요.</p>
</blockquote>
<h2 id="사용-가능한-툴들"><a class="header" href="#사용-가능한-툴들">사용 가능한 툴들</a></h2>
<h3 id="windowperformancenow-타이머"><a class="header" href="#windowperformancenow-타이머"><code>window.performance.now()</code> 타이머</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><code>performance.now()</code> 함수</a>는 웹 페이지가 로드된 시점부터 측정된 밀리초 단위의 단조 시간 (monotonic timestamp)를 반환합니다.</p>
<p><code>performance.now</code>를 호출할 때에는 거의 오버헤드가 발생하지 않습니다. 그러므로 시스템 성능에 큰 영향을 주거나 측정 값에 편향을 주지 않으면서 간단하고 상세한 측정을 원활하게 할 수 있게 됩니다.</p>
<p>이 함수를 사용하여 프로그램의 여러 작업들이 실행되는 시간을 측정해 볼 수 있고, <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html"><code>web-sys</code> 크레이트</a>를 통해 <code>window.performance.now()</code>에 접근할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

fn now() -&gt; f64 {
    web_sys::window()
        .expect("should have a Window")
        .performance()
        .expect("should have a Performance")
        .now()
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/fn.window.html"><code>web_sys::window</code> 함수</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.performance"><code>web_sys::Window::performance</code> 메소드</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Performance.html#method.now"><code>web_sys::Performance::now</code> 메소드</a></li>
</ul>
<h3 id="개발자-도구-내의-프로파일러"><a class="header" href="#개발자-도구-내의-프로파일러">개발자 도구 내의 프로파일러</a></h3>
<p>모든 웹 브라우저의 개발자 도구는 프로파일러를 포함하고 있습니다. 이러한 프로파일러들은 "call tree"나 "flame graph"와 같은 일반적인 시각 자료와 함께 어떤 함수들이 가장 많은 시간을 소비하는지 표시해 줍니다.</p>
<p>"name" 커스텀 섹션이 wasm 바이너리에 포함되도록 <a href="reference/./debugging.html#building-with-debug-symbols">debug 심볼을 포함해서 빌드</a>하면 프로파일러가 <code>wasm-function[123]</code>와 같이 복잡하고 불투명한 이름 대신 Rust 함수 이름을 대신 표시하게 됩니다.</p>
<p>이러한 프로파일러들은 인라인 함수를 <strong>표시하지 않는다는</strong> 점을 기억해 주세요. Rust와 LLVM는 인라인 작업을 매우 무겁게 수행하기 때문에 이러한 작업을 해주더라도 결괏값이 조금은 읽기 어려울수 있습니다.</p>
<p><a href="reference/../images/game-of-life/profiler-with-rust-names.png"><img src="reference/../images/game-of-life/profiler-with-rust-names.png" alt="Rust 심볼을 표시하는 프로파일러 스크린샷" /></a></p>
<h4 id="추가-자료"><a class="header" href="#추가-자료">추가 자료</a></h4>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Performance">Firefox 개발자 도구 — 성능</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/performance">Microsoft Edge 개발자 도구 — 성능</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution">Chrome DevTools JavaScript 프로파일러</a></li>
</ul>
<h3 id="consoletime와-consoletimeend-함수"><a class="header" href="#consoletime와-consoletimeend-함수"><code>console.time</code>와 <code>console.timeEnd</code> 함수</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/time"><code>console.time</code> 과 <code>console.timeEnd</code> 함수</a>를 사용해서 브라우저 개발자 도구 콘솔에 명명된 작업의 타이밍을 기록할 수 있습니다. 작업이 시작될 때 <code>console.time("어떤 거 하는 작업")</code>를 호출하고, 작업이 완료될 때는 <code>console.timeEnd("어떤 거 하는 작업")</code>를 호출합니다. 참고로 작업의 이름을 지어주는 문자열 인자는 필수가 아닙니다.</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html"><code>web-sys</code> 크레이트</a>를 통해 이러한 함수들을 직접적으로 사용할 수 있습니다:</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_with_label.html"><code>web_sys::console::time_with_label("어떤 거 하는 작업")</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_end_with_label.html"><code>web_sys::console::time_end_with_label("어떤 거 하는 작업")</code></a></li>
</ul>
<p>브라우저의 콘솔에 <code>console.time</code> 로그를 표시하는 스크린샷을 확인해보세요:</p>
<p><a href="reference/../images/game-of-life/console-time.png"><img src="reference/../images/game-of-life/console-time.png" alt="console.time 로그 스크린샷" /></a></p>
<p>추가로, 다음 이미지에 보이는 것과 같이 브라우저 프로파일러의 "timeline"과 "waterfall" 뷰에 <code>console.time</code>과 <code>console.timeEnd</code>의 로그가 표시됩니다.</p>
<p><a href="reference/../images/game-of-life/console-time-in-profiler.png"><img src="reference/../images/game-of-life/console-time-in-profiler.png" alt="console.time 로그 스크린샷" /></a></p>
<h3 id="bench-속성으로-네이티브-환경을-사용할-때"><a class="header" href="#bench-속성으로-네이티브-환경을-사용할-때"><code>#[bench]</code> 속성으로 네이티브 환경을 사용할 때</a></h3>
<p>웹 브라우저에서 <code>#[test]</code> 속성을 대신 이용하여 운영체제의 네이티브 코드로 디버깅을 했던 것과 같이, <code>#[bench]</code> 속성과 함께 함수를 작성해서 운영 체제의 네이티브 코드 프로파일링 툴을 사용해 볼 수도 있습니다.</p>
<p>작업 중인 크레이트의 하위 경로인 <code>benches</code>에 벤치마킹 코드를 작성해 보겠습니다. 먼저 <code>crate-type</code>이 <code>"rlib"</code>이 포함하고 있는지 확인해 주세요. 그렇지 않다면 벤치마크 바이너리가 메인 라이브러리 (main lib) 에 링크되지 못하게 됩니다.</p>
<p>하지만 실제로는 거의 사용하지 않는 코드에 시간을 소비하고 있을 수도 있으니, 네이티브 코드로 벤치마킹을 하기 전에 브라우저 프로파일링 툴을 먼저 확인해 보는 것도 좋습니다!</p>
<h4 id="추가-자료-1"><a class="header" href="#추가-자료-1">추가 자료</a></h4>
<ul>
<li><a href="http://www.brendangregg.com/perf.html">Linux 환경에서 <code>perf</code> 프로파일러 사용하기</a></li>
<li><a href="https://help.apple.com/instruments/mac/current/">macOS 환경에서 Instruments.app 프로파일러 사용하기</a></li>
<li><a href="https://software.intel.com/en-us/vtune">VTune 프로파일러는 Windows와 Linux를 지원합니다.</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-파일-사이즈-줄이기-1"><a class="header" href="#wasm-파일-사이즈-줄이기-1"><code>.wasm</code> 파일 사이즈 줄이기</a></h1>
<p>이 섹션에서는 어떻게 Rust 코드를 수정하고 <code>.wasm</code> 빌드를 최적화해야 더 작은 사이즈의 바이너리를 출력할 수 있는지 살펴보겠습니다.</p>
<h2 id="왜-출력되는-파일의-사이즈가-중요한가요"><a class="header" href="#왜-출력되는-파일의-사이즈가-중요한가요">왜 출력되는 파일의 사이즈가 중요한가요?</a></h2>
<p><code>.wasm</code> 파일을 네트워크로 전송할 때 파일의 사이즈가 작을수록 클라이언트에서 더 빠르게 다운로드 할 수 있습니다. <code>.wasm</code> 파일이 빨리 다운로드 될수록 페이지가 더 빨리 로드되고 유저 경험이 더 나아지게 됩니다.</p>
<p>하지만 코드 사이즈가 어쩌면 제일 중요하게 확인해야 할 부분이 아닐 수도 있습니다. 모호하고 측정하기 어렵겠지마 "페이지가 로드되고 사용할 수 있게 될 때까지 걸리는 시간"이 실제로는 더 중요하게 고려해 봐야 할 부분일 수도 있습니다. (코드가 로드돼야 사이트가 작동하기 시작한다는 내용을 생각해 본다면) 코드 사이즈가 이 시간에 큰 영향을 미치긴 하지만 이게 유일하게 확인해야 할 부분은 아닌 것을 알 수 있습니다.</p>
<p>WebAssembly는 보통 gzip 파일 포맷 형식으로 압축되어 전송되는데, 그러므로 유선을 통해 파일을 더 빠르게 보낼 수 있도록 gzip 포맷으로 압축된 파일의 사이즈를 비교해야 합니다. 참고로 WebAssembly 바이너리 포맷은 gzip 포맷에 적합하므로 50% 이상으로 사이즈를 줄일 수 있습니다.</p>
<p>게다가, WebAssembly의 바이너리 포맷은 매우 빠르게 읽고 처리할 수 있도록 최적화가 잘 되어있습니다. 요즘 사용되는 브라우저들은 보통 "baseline compilers" 라는 기능을 가지고 있는데, 이 기능을 통해 네트워크로 wasm 파일을 보내는 동시에 동일하게 빠른 속도로 전송받은 WebAssembly 코드를 네이티브 기계어로 컴파일할 수 있습니다. 그렇기 때문에 <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/"><code>instantiateStreaming</code>을 사용한다면</a> 웹페이지가 한 번 로드 된 이후부터는 WebAssembly 모듈을 바로 사용할 수 있게 됩니다. 반면에 JavaScript 코드를 실행할 때는 주로 파싱하는 처리 외에도 코드를 빠르게 실행할 수 있도록 JIT 컴파일 과정 등을 거쳐야 하기 때문에 주로 시간이 더 오래 걸리게 됩니다.</p>
<p>마지막으로, WebAssembly가 실행 속도 측면에서 JavaScript와 비교했을 때 훨씬 최적화가 잘 돼있다는 부분을 기억해주세요. 더 확실하게 하고 싶다면 JavaScript와 WebAssembly 런타임 속도를 각각 측정해 보고 코드 사이즈가 얼마나 중요한지 확인해볼수도 있습니다.</p>
<p>하지만 <code>.wasm</code> 파일의 사이즈가 예상보다 크더라도 바로 낙담하지는 말아주세요! 코드 사이즈는 큰 그림의 일부일 뿐입니다. JavaScript와 WebAssembly를 비교할 때 코드 사이즈만 비교하게 된다면 많은 부분을 놓치게 됩니다.</p>
<h2 id="코드-사이즈를-줄일-수-있도록-빌드-최적화하기"><a class="header" href="#코드-사이즈를-줄일-수-있도록-빌드-최적화하기">코드 사이즈를 줄일 수 있도록 빌드 최적화하기</a></h2>
<p><code>rustc</code>에는 더 작은 <code>.wasm</code> 바이너리를 생성할 때 유용한 옵션을 몇가지 가지고 있습니다. 어떤 상황에서는, 컴파일 시간이 더 오래 걸리는 부분을 희생해서 <code>.wasm</code> 사이즈를 더 작게 줄이기도 합니다. 또 다른 경우에는, 더 빠른 런타임을 위해 <code>.wasm</code> 파일 사이즈를 포기하기도 합니다. 각 옵션의 장단점을 잘 이해하고, 프로파일링과 측정 작업을 해보면서 코드 사이즈와 런타임 속도 중 어떤 것이 우선시되어야 하는지 잘 알고 결정하는 것이 중요합니다.</p>
<h3 id="링크-시간-최적화-link-time-optimizations-lto-을-사용해서-컴파일하기"><a class="header" href="#링크-시간-최적화-link-time-optimizations-lto-을-사용해서-컴파일하기">링크 시간 최적화 (Link Time Optimizations, LTO) 을 사용해서 컴파일하기</a></h3>
<p><code>Cargo.toml</code> 파일의 <code>[profile.release]</code> 섹션에 <code>lto = true</code>를 추가해 주세요:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<p>이렇게 LLVML이 사용하지 않는 코드를 더 공격적으로 제거하고 인라인 작업을 더 적극적으로 처리할 수 있도록 설정할 수 있습니다. LTO를 사용하면 <code>.wasm</code> 파일의 사이즈가 작아질 뿐 아니라, 런타임을 더 빠르게 만들 수도 있습니다! 하지만 컴파일 작업이 더 오래 걸린다는 단점이 있으니 참고해 주세요.</p>
<h3 id="런타임-속도-대신-코드-사이즈를-최적화하도록-llvm-설정하기"><a class="header" href="#런타임-속도-대신-코드-사이즈를-최적화하도록-llvm-설정하기">런타임 속도 대신 코드 사이즈를 최적화하도록 LLVM 설정하기</a></h3>
<p>LLVM의 최적화 작업은 기본적으로 사이즈 대신 속도 개선에 중점을 두고 진행됩니다. <code>[profile.release]</code>파일의 <code>[profile.release]</code> 섹션을 수정하여 이 설정을 변경할 수도 있습니다:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>추가로 발생할 수 있는 속도 저하를 감수해서라도 더 공격적으로 최적화를 해볼 수도 있습니다:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>정말 놀랍게도, 출력되는 파일의 사이즈가 <code>opt-level = "z"</code>대신 <code>opt-level = "s"</code>를 사용했을 때 더 작아지는 경우도 있습니다. 항상 잘 확인해 보는 걸 잊지 말아 주세요!</p>
<h3 id="wasm-opt-툴-사용하기"><a class="header" href="#wasm-opt-툴-사용하기"><code>wasm-opt</code> 툴 사용하기</a></h3>
<p><a href="https://github.com/WebAssembly/binaryen">Binaryen</a> 툴킷은 WebAssembly에 특화된 컴파일러 툴링을 포함합니다. 단순히 LLVM의 WebAssembly 백엔드 작업 외에도 훨씬 더 다양한 작업에 사용할 수 있고, <code>wasm-opt</code> 툴을 사용해서 LLVM이 빌드한 <code>.wasm</code> 바이너리를 최적화 하면 보통은 코드 사이즈를 15-20% 정도 더 줄일 수 있게 됩니다. 런타임 속도도 같이 개선될 수도 있으니 참고해 주세요!</p>
<pre><code class="language-bash"># 사이즈 최적화.
wasm-opt -Os -o output.wasm input.wasm

# 공격적인 사이즈 최적화.
wasm-opt -Oz -o output.wasm input.wasm

# 속도 최적화.
wasm-opt -O -o output.wasm input.wasm

# 공격적인 속도 최적화.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<h3 id="디버그-정보에-관해-알아두면-좋은-점"><a class="header" href="#디버그-정보에-관해-알아두면-좋은-점">디버그 정보에 관해 알아두면 좋은 점</a></h3>
<p>wasm 바이너리 사이즈를 줄이는 데 바이너리 파일에 포함된 디버그 정보와 <code>names</code> 섹션이 정말 큰 역할을 합니다. 하지만 <code>wasm-pack</code>이 기본값으로 디버그 정보를 삭제하고, 추가로 <code>wasm-opt</code>도 명령어에 <code>-g</code>가 포함되지 않는 이상 <code>names</code> 섹션을 기본적으로 지우는 부분을 잘 기억해 주세요.</p>
<p>이 책을 잘 따라왔다면 기본적으로는 디버그 정보나 <code>names</code> 섹션 없이 wasm파일을 빌드하게 됩니다. 하지만, 이러한 디버깅 정보가 wasm 바이너리에 포함돼야 하는 상황에서는 이 내용을 잘 참고해 주세요!</p>
<h2 id="사이즈-프로파일링하기"><a class="header" href="#사이즈-프로파일링하기">사이즈 프로파일링하기</a></h2>
<p>빌드 최적화 설정을 바꿨는데도 <code>.wasm</code> 코드 사이즈가 충분히 줄어들지 않는다면, 어떤 부분이 나머지 공간을 사용하는지 프로파일링 작업을 해보면서 알아보도록 합시다.</p>
<blockquote>
<p>⚡ 타임 프로파일링 가이드를 따라왔던 것처럼, 사이즈 프로파일링 가이드도 한번 읽어보고 시도해 봅시다. 읽어보는 것만으로도 시간을 정말 많이 아낄 수 있습니다!</p>
</blockquote>
<h3 id="twiggy-코드-사이즈-프로파일러"><a class="header" href="#twiggy-코드-사이즈-프로파일러"><code>twiggy</code> 코드 사이즈 프로파일러</a></h3>
<p><a href="https://github.com/rustwasm/twiggy"><code>twiggy</code></a>는 WebAssembly를 입력으로 받는 코드 사이즈 프로파일러입니다. 바이너리의 <a href="https://en.wikipedia.org/wiki/Call_graph">호출 그래프 (call graph)</a> 를 분석하고 다음곽 같은 내용을 알려줍니다:</p>
<ul>
<li>
<p>어떤 함수들이 애초에 왜 바이너리에 포함되는 건가요?</p>
</li>
<li>
<p>이 함수에 <em>사용되는 공간의 크기</em>가 어떻게 되나요? 예: 이 함수와 내부에서 호출해서 사용하게 되는 함수들까지 제거한다면 얼마나 공간을 아낄 수 있나요?</p>
</li>
</ul>
<style>
/* 알 수 없는 이유로 mdbook의 기본 폰트가 box-drawing character와 호환이 되지 않아서 직접 스타일을 따로 생성했습니다. */
pre, code {
  font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
</style>
<pre><code class="language-text">$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────
          9158 ┊    19.65% ┊ "function names" subsection
          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8
          2510 ┊     5.39% ┊ &lt;str as core::fmt::Debug&gt;::fmt::he0d87479d1c208ea
          1737 ┊     3.73% ┊ data[0]
          1574 ┊     3.38% ┊ data[3]
          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5
          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d
          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced
          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b
          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605
           931 ┊     2.00% ┊ data[4]
           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05
           841 ┊     1.80% ┊ &lt;char as core::fmt::Debug&gt;::fmt::h07742d9f4a8c56f2
           813 ┊     1.74% ┊ __rust_realloc
           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85
           678 ┊     1.45% ┊ &lt;core::fmt::builders::PadAdapter&lt;'a&gt; as core::fmt::Write&gt;::write_str::h96b72fb7457d3062
           631 ┊     1.35% ┊ universe_tick
           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8
           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5
           503 ┊     1.08% ┊ &lt;&amp;'a T as core::fmt::Debug&gt;::fmt::hba207e4f7abaece6
</code></pre>
<h3 id="llvm-ir-직접-살펴보기"><a class="header" href="#llvm-ir-직접-살펴보기">LLVM-IR 직접 살펴보기</a></h3>
<p>LLMV-IR은 LLVM이 WebAssembly를 출력하기 전에 거치게 되는 최종 중간 표현 (final intermediate representation) 입니다. 이 최종 중간 표현은 최종적으로 출력하는 WebAssembly 바이너리와 매우 유사하게 생겼습니다. LLVM-IR의 크기가 클수록 출력되는 <code>.wasm</code> 파일의 크기도 커지게 되고, 함수들이 LLVM-IR 크기의 25%까지 차지하게 된다면 <code>.wasm</code> 파일에서도 함수들이 마찬가지로 25%를 차지하게 됩니다. 이러한 수치들이 보통은 일치하지만, LLVM-IR은 <code>.wasm</code> 파일이 (DWARF와 같은 디버깅 정보 처럼) 가지고 있지 않는 다른 중요한 정보들도 가지고 있는 점 또한 잘 참고해 주세요. 이러한 하위 루틴들은 해당 함수의 위치에 인라인됩니다.</p>
<p><code>cargo</code> 명령어를 실행해서 LLVM-IR 파일을 직접 생성해 보세요:</p>
<pre><code>cargo rustc --release -- --emit llvm-ir
</code></pre>
<p>그다음 <code>find</code> 명령어를 사용해서 <code>.ll</code> 파일을 검색해 보겠습니다. 이 LLVM-IR 파일은 <code>cargo</code>의 <code>target</code> 경로에 위치하게 됩니다:</p>
<pre><code>find target/release -type f -name '*.ll'
</code></pre>
<h4 id="참조-3"><a class="header" href="#참조-3">참조</a></h4>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM 언어 참조 메뉴얼</a></li>
</ul>
<h2 id="툴과-테크닉을-활용하여-더-깊게-파고들어서-최적화하기"><a class="header" href="#툴과-테크닉을-활용하여-더-깊게-파고들어서-최적화하기">툴과 테크닉을 활용하여 더 깊게 파고들어서 최적화하기</a></h2>
<p><code>.wasm</code> 바이너리 사이즈를 줄이는 설정은 보통 자동화가 돼 있습니다. 하지만 추가로 불필요한 코드를 제거하고 최적화를 해줘야 하는 경우에는 더 깊게 들어가서 수정해 줘야 할 때가 있습니다. 이 섹션에서는 코드 사이즈를 줄일 때 사용해 볼 수 있는 투박한 방법들에 대해 알아보겠습니다.</p>
<h3 id="문자열-포맷-피하기"><a class="header" href="#문자열-포맷-피하기">문자열 포맷 피하기</a></h3>
<p><code>format!</code>이나 <code>to_string</code> 과 같은 함수/매크로들을 사용하면 출력되는 바이너리의 사이즈가 불필요하게 커질 수도 있습니다. 가능하면 문자열 포맷은 디버그 모드에서만 사용하고, 배포 버전을 빌드할 때에는 정적 문자열 (static string) 을 사용해 보세요.</p>
<h3 id="코드-패닉-피하기"><a class="header" href="#코드-패닉-피하기">코드 패닉 피하기</a></h3>
<p>말처럼 쉽지는 않겠지만, <code>twiggy</code> 와 같은 툴을 사용하거나 LLVM-IR 파일을 살펴보면서 어떤 함수들이 패닉하는지 살펴볼 수 있습니다.</p>
<p>패닉이 항상 <code>panic!()</code> 매크로의 형식으로 나타나지는 않고 보통은 다음과 같은 여러 가지 다양한 이유로 발생할 수 있습니다:</p>
<ul>
<li>
<p>슬라이스 사이즈 범위를 벗어난 인덱스의 요소에 접근하고자 시도할 때 (out of bounds) : <code>my_slice[i]</code></p>
</li>
<li>
<p>나머지 연산자를 사용할 때 나누는 수가 0인 경우: <code>나눠지는 수 / 나누는 수</code></p>
</li>
<li>
<p><code>Option</code>이나 <code>Result</code>의 값을 <code>unwrap()</code>를 사용하여 값에 접근할 때: <code>opt.unwrap()</code> 또는 <code>res.unwrap()</code></p>
</li>
</ul>
<p>처음 두 방법 대신 사용해 볼 수 있는 더 안전한 방법들도 있습니다. <code>my_slice[i]</code> 처럼 인덱스를 통해 직접 접근하지 않고 <code>my_slice.get(i)</code> 를 사용하여 <code>Option</code> 타입의 값에 접근해 볼 수도 있고, <code>check_div</code> 함수를 불러서 값을 나눌수 있는지 확인해 볼 수도 있습니다. 이렇게 3번째 경우만 집중적으로 신경 쓸 수 있게 됐습니다.</p>
<p>추가로, 코드를 패닉 시키지 않으면서 <code>Option</code>이나 <code>Result</code> 타입의 값을 "안전한 방법과 불안전한 방법", 두 가지 방법으로 처리해볼수도 있습니다.</p>
<p>안전한 방법부터 한번 살펴보도록 합시다. <code>None</code>이나 <code>Error</code> 값을 반환받았을 때 코드를 패닉시키는 대신 <code>abort</code> 함수를 사용해 보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub fn unwrap_abort&lt;T&gt;(o: Option&lt;T&gt;) -&gt; T {
    use std::process;
    match o {
        Some(t) =&gt; t,
        None =&gt; process::abort(),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>최종적으로는 패닉 코드가 <code>wasm32-unknown-unknown</code> 타겟의 abort 명령어로 옮겨지기 때문에, 이런 식으로 코드를 작성하면서 불필요한 코드를 지울 수 있게 됩니다.</p>
<p>다른 시도해볼수 있는 방법으로는, <a href="https://crates.io/crates/unreachable"><code>unreachable</code> 크레이트</a>가 있습니다. 이 크레이트는 <code>Option</code>과 <code>Result</code> 타입의 값들과 함께 사용할 수 있도록 불안전한 <a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap"><code>unchecked_unwrap</code> 확장 크레이트들</a>을 제공하는데, 컴파일러가 <code>Option</code>을 <code>Some</code>으로, <code>Result</code>를 <code>Ok</code>로 <em>추측</em>해서 옮길 수 있도록 도와줍니다. 하지만 이런 추측이 맞아떨어지지 않으면 정의하지 않은 동작 (undefined behavior) 이 발생하게 되므로 코드가 잘 작동한다고 확신하지만 컴파일러가 잘 모르고 있는 상황을 <em>잘 이해하고 있을 때만</em> 이 방법을 사용해 주세요. 일반적으로는 이 방법을 배포 버전에서만 적용하고 그 외에는 컴파일러가 확인할 수 있도록 디버그 빌드를 따로 설정하길 권장합니다.</p>
<h3 id="할당을-피하거나-wee_alloc을-대신-사용해-보세요"><a class="header" href="#할당을-피하거나-wee_alloc을-대신-사용해-보세요">할당을 피하거나 <code>wee_alloc</code>을 대신 사용해 보세요.</a></h3>
<p>Rust는 기본값으로 <code>dlmalloc</code>라는 할당자를 이식해서 사용합니다. 이 할당자는 10 KB 정도의 사이즈를 차지하게 되는데, 동적 할당을 사용하지 않아도 괜찮다면 이 사이즈를 절약해 볼 수도 있습니다.</p>
<p>완전히 동적 할당 없이 작업하기가 사실은 쉽지는 않은 편인데, 코드의 <a href="https://en.wikipedia.org/wiki/Hot_spot_(computer_programming)">핫 스팟 (hot spot)</a> 에서 할당을 없애는 작업은 대부분은 훨씬 쉬운 편입니다. (보통은 이 작업을 통해 핫 스팟인 코드들을 훨씬 빠르게 만들 수도 있습니다.) 이러한 상황에서 <a href="https://github.com/rustwasm/wee_alloc">전역 할당자 대신 <code>wee_alloc</code>를 사용하면</a> (전부는 아니지만) 이 10 KB 만큼 차지되는 공간의 대부분을 절약할 수 있습니다. <code>wee_alloc</code>는 할당자를 필요로 하지만 굳이 아주 빠를 필요가 없고, 실행 속도가 느려지는 대신 코드 사이즈를 줄여도 괜찮을 때 사용하도록 설계됐습니다.</p>
<h3 id="제네릭-타입-매개변수-대신-트레이트-객체를-사용해-보세요"><a class="header" href="#제네릭-타입-매개변수-대신-트레이트-객체를-사용해-보세요">제네릭 타입 매개변수 대신 트레이트 객체를 사용해 보세요</a></h3>
<p>다음 예시와 같이 타입 매개변수를 사용하는 제네릭 함수를 작성한다고 가정해 봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever&lt;T: MyTrait&gt;(t: T) { ... }
<span class="boring">}</span></code></pre></pre>
<p><code>rustc</code>와 LLVM는 제네릭 함수가 호출될 때 사용된 타입에 해당하는 바이너리 코드를 각각 따로 생성합니다. 이런 접근은 어떤 <code>T</code> 타입을 컴파일러가 처리하는지에 따라 컴파일러 최적화에 유용할 수도 있습니다. 하지만 동시에 코드 사이즈가 빠르게 늘어날 수도 있다는 단점도 가지고 있습니다.</p>
<p>다음과 같이 타입 매개변수 대신 트레이트 객체를 사용해 보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever(t: Box&lt;MyTrait&gt;) { ... }
// or
fn whatever(t: &amp;MyTrait) { ... }
// etc...
<span class="boring">}</span></code></pre></pre>
<p>이 코드를 컴파일할때 가상 환경에서 함수들을 동적 디스패치 (dynamic dispatch) 라는 메커니즘으로 처리를 하게 되는데, 한 가지 버전의 함수만 <code>.wasm</code> 파일로 처리되게 됩니다. 이러한 처리를 하면서 컴파일러 최적화 측면에서 손실이 있을 수 있고, 간접적이고 동적으로 디스패치된 함수를 부르는데 추가적인 비용이 들수도 있다는 단점이 있습니다.</p>
<h3 id="wasm-snip-툴을-사용해-보세요"><a class="header" href="#wasm-snip-툴을-사용해-보세요"><code>wasm-snip</code> 툴을 사용해 보세요</a></h3>
<p><a href="https://github.com/fitzgen/wasm-snip"><code>wasm-snip</code>은 WebAssembly 함수의 코드를 <code>unreachable</code> Assembly 명령어로 교체해 줍니다.</a> 하지만 잘 생각해보면 못 하나를 박는다고 아주 거대한 망치를 가져와서 열심히 두드리는 것 같은 느낌이 조금씩 듭니다.</p>
<p>런타임에서 사용하지 않는 함수들과 이 함수들이 간접적으로 호출하는 다른 함수들을 제거하고  싶은데, 컴파일러가 어떤 함수를 사용하지 않는지 모른다면 어떻게 해야 할까요? 우선은 코드를 빌드해보고 <code>wasm-opt</code>를 <code>--dce</code> 플래그를 포함해서 다시 실행해 보세요! 간접적으로 호출되는 (런타임에서 부르지 않는) 함수들까지 지워버릴 수 있습니다.</p>
<p>패닉 코드가 이런 문제들로 종종 이어질 수 있기 때문에, 패닉 인프라 (panicking infrastructure) 를 지울 때 이 툴이 유용하게 사용될 수도 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-상호-운용하기"><a class="header" href="#javascript-상호-운용하기">JavaScript 상호 운용하기</a></h1>
<h2 id="javascript-함수-임포트하고-익스포트하기"><a class="header" href="#javascript-함수-임포트하고-익스포트하기">JavaScript 함수 임포트하고 익스포트하기</a></h2>
<h3 id="rust-사이드"><a class="header" href="#rust-사이드">Rust 사이드</a></h3>
<p>JavaScript 환경에서 wasm을 사용할 때 Rust 사이드에서 함수들을 임포트하고 익스포팅하는 작업은 의외로 매우 간단합니다. 그리고 C 언어와 유사하게 작동하기도 합니다.</p>
<p>WebAssembly 모듈은 임포트 시퀀스(sequence)를 선언하는데, 각각 시퀀스는 <em>모듈 이름</em>과 <em>임포트 이름</em>으로 구성됩니다. 기본값으로 "env" 파일에 설정된 것과 같이, <a href="https://github.com/rust-lang/rust/issues/52090"><code>#[link(wasm_import_module)]</code></a>를 사용하여 <code>extern { ... }</code> 블럭 모듈 이름을 직접 지정해 줄 수도 있습니다.</p>
<p>익스포트는 한가지 이름만 가질 수 있는데, 다른 <code>extern</code> 함수들과 마찬가지로, WebAssembly 인스턴스의 선형 메모리는 기본값으로는 "memory" 라는 이름으로 익스포트 됩니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `foo`라는 JavaScript 함수를 `mod` 모듈에서 임포트해옵니다.
#[link(wasm_import_module = "mod")]
extern { fn foo(); }

// `bar`라는 Rust 함수를 익스포트합니다.
#[no_mangle]
pub extern fn bar() { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>wasm은 제한된 수의 값 타입들을 가지고 있기 때문에, 이러한 함수들은 원시 숫자 타입에서만 작동해야 한다는 부분도 참고해 주세요.</p>
<h3 id="javascript-사이드"><a class="header" href="#javascript-사이드">JavaScript 사이드</a></h3>
<p>JavaScript 코드 내에서는 wasm 바이너리가 ES6 모듈로 변환되는 것을 확인할 수 있습니다. 이 모듈은 선형 메모리와 함께 먼저 <em>인스턴스화</em> 돼야하고, 임포트한 내용과 일치하는 JavaScript 함수 그룹을 필요로 합니다. 인스턴스화에 대해 더 자세히 알아보려면 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">MDN</a>를 참고해 주세요.</p>
<p>출력하게 되는 ES6 모듈은 Rust에서 익스포트한 함수들을 모두 포함하게 되는데, 이런 함수들은 JavaScript 함수에서 호출할 수 있습니다.</p>
<p>셋업을 하고 실행시키는 전반적으로 간단한 예시를 확인하고 싶다면 <a href="https://www.hellorust.com/demos/add/index.html">여기</a>를 참고해 주세요.</p>
<h2 id="숫자-외에-다른-값도-사용해보기"><a class="header" href="#숫자-외에-다른-값도-사용해보기">숫자 외에 다른 값도 사용해보기</a></h2>
<p>JavaScript에서 wasm을 사용할 때는 wasm 모듈의 메모리와 JavaScript 메모리 사이가 명확하게 구분됩니다:</p>
<ul>
<li>
<p>(이 문서 최상단에 설명된 대로) 각각의 wasm 모듈은 인스턴스화 과정에서 생성하게 되는 선형 메모리를 가지게 됩니다. <strong>JavaScript 코드는 자유롭게 이 메모리를 읽고 쓸 수 있습니다.</strong></p>
</li>
<li>
<p>반면에, wasm에서는 JavaScript 객체에 직접 접근할 수 없습니다.</p>
</li>
</ul>
<p>그런 이유로 보통은 두 가지 방법으로 정교화된 상호작용을 처리하게 됩니다:</p>
<ul>
<li>
<p>바이너리 데이터를 wasm 메모리에서 복사하거나 붙여놓습니다. 예를 들어서, 이 방법으로 Rust 코드가 소유하는 <code>String</code> 값을 사용할 수도 있습니다.</p>
</li>
<li>
<p>명시적으로 JavaScript 객체의 힙을 설정하고 이후에 "addresses"를 할당합니다. 이렇게 wasm 코드에서 (정수 값을 사용하여) 간접적으로 JavaScript 객체를 참조할 수 있고, 임포트한 JavaScript 함수를 호출해서 사용할 수 있게 됩니다.</p>
</li>
</ul>
<p>다행스럽게도 이 상호 운용 작업은 <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a>이라는 <code>bindgen</code> 스타일의 프레임워크를 사용해서 아주 쉽게 처리할 수 있습니다. 이 프레임워크를 사용해서 관용적인 스타일의 JavaScript 함수에 자동으로 매핑되도록 관용적인 Rust 함수 시그니처를 생성할 수 있습니다.</p>
<h2 id="사용자-정의-섹션-custom-sections"><a class="header" href="#사용자-정의-섹션-custom-sections">사용자 정의 섹션 (Custom Sections)</a></h2>
<p>사용자 정의 섹션을 통해 wasm 모듈에 명명된 임의의 데이터를 임베딩할 수 있습니다. 이 섹션 데이터는 컴파일 시점에 설정되며 wasm 모듈에서 직접 읽을 수 있지만 런타임에서는 이 모듈을 수정할 수 없습니다.</p>
<p>Rust 코드에서 다음과 같이 사용자 정의 섹션을 정적 배열 (<code>[T; size]</code>)로 나타내고 <code>#[link_section]</code> 속성으로 노출시킬 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link_section = "hello"]
pub static SECTION: [u8; 24] = *b"This is a custom section";
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 wasm 파일에 <code>hello</code> 라는 사용자 정의 섹션을 추가합니다. 변수 이름 <code>SECTION</code> 은 임의로 명명됐으며 이 이름을 변경해도 코드의 동작이 바뀌지 않습니다. 이 변수에 텍스트 바이트 (bytes of text) 를 사용했지만 다른 임의의 데이터를 사용할 수도 있습니다.</p>
<p>이런 사용자 정의 섹션은 JS 사이드에서 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections"><code>WebAssembly.Module.customSections</code></a>  함수를 사용하여 읽을 수도 있습니다. 이 함수를 호출할 때, wasm 모듈과 섹션 이름을 인자로 주고 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>의 배열을 반환받게 됩니다. 여러 섹션들이 같은 이름을 공유하게 할 수도 있는데, 이 경우에는 한 배열에 여러 섹션들을 담게 됩니다.</p>
<pre><code class="language-js">WebAssembly.compileStreaming(fetch("sections.wasm"))
.then(mod =&gt; {
  const sections = WebAssembly.Module.customSections(mod, "hello");

  const decoder = new TextDecoder();
  const text = decoder.decode(sections[0]);

  console.log(text); // -&gt; "사용자 정의 섹션을 콘솔에 출력합니다"
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="어떤-크레이트들을-webassembly에서-바로-사용할-수-있나요"><a class="header" href="#어떤-크레이트들을-webassembly에서-바로-사용할-수-있나요">어떤 크레이트들을 WebAssembly에서 바로 사용할 수 있나요?</a></h1>
<p>가장 간단하게 어떤 기능들이 WebAssembly 환경에서 작동하지 않는지 목록을 한번 만들어 보겠습니다. 다음 내용에 해당하지 않는 크레이트들은 휴대성이 좋고 WebAssembly 환경에서 잘 작동한다고 생각해도 좋고, 임베디드 시스템과 <code>#![no_std]</code>를 지원하는 크레이트들도 보통은 WebAssembly도 지원한다고 볼수 있습니다.</p>
<h2 id="이러한-크레이트들은-webassembly-환경에서-작동하지-않을-수도-있습니다"><a class="header" href="#이러한-크레이트들은-webassembly-환경에서-작동하지-않을-수도-있습니다">이러한 크레이트들은 WebAssembly 환경에서 작동하지 않을 수도 있습니다</a></h2>
<h3 id="c-언어와-시스템-라이브러리-종속성이-있는-경우"><a class="header" href="#c-언어와-시스템-라이브러리-종속성이-있는-경우">C 언어와 시스템 라이브러리 종속성이 있는 경우</a></h3>
<p>wasm에는 시스템 라이브러리가 없기 떄문에 시스템 라이브러리에 바인딩돼 있는 코드가 있다면 작동하지 않습니다.</p>
<p>wasm에는 언어 간 통신에 사용할 수 있는 안정된 버전의 ABI와 언어 간 링킹(linking)이 존재하지 않습니다. 그러므로 C 라이브러리를 사용하는 크레이트도 작동하지 않습니다. 특히 <code>clang</code> 컴파일러가 <code>wasm32</code> 타겟을 기본으로 제공하기 때문에 결국은 작동할 것으로 예상되지만, 현재로서는 완벽하지 않습니다.</p>
<h3 id="파일-io"><a class="header" href="#파일-io">파일 I/O</a></h3>
<p>WebAssembly는 파일 시스템에 접근할 수 없습니다. — 파일 시스템을 필요로 하고 wasm에서 사용할 수 있도록 코드가 마련되지 않은 크레이트는 작동하지 않습니다.</p>
<h3 id="스레드-생성"><a class="header" href="#스레드-생성">스레드 생성</a></h3>
<p><a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html">스레딩을 웹어셈블리에 지원하는 계획</a>이 있긴 하지만 아직 준비가 완벽히 되지 않았습니다. <code>wasm32-unknown-unknown</code> 타겟에서 스레드를 생성하려고 시도하면 wasm 트랩 (wasm trap) 이 발생하면서 코드가 패닉하게 됩니다.</p>
<h2 id="어떤-다목적-크레이트들이-webassembly에서-바로-작동하는-편인가요"><a class="header" href="#어떤-다목적-크레이트들이-webassembly에서-바로-작동하는-편인가요">어떤 다목적 크레이트들이 WebAssembly에서 바로 작동하는 편인가요?</a></h2>
<h3 id="알고리즘과-자료-구조"><a class="header" href="#알고리즘과-자료-구조">알고리즘과 자료 구조</a></h3>
<p><a href="https://ko.wikipedia.org/wiki/A*_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">A* 알고리즘</a>나 <a href="https://en.wikipedia.org/wiki/Splay_tree">splay trees</a>처럼, 특정한 <a href="https://crates.io/categories/algorithms">알고리즘</a>이나 <a href="https://crates.io/categories/data-structures">data structure</a>의 구현을 제공하는 크레이트들은 WebAssembly와 잘 작동하는 편입니다.</p>
<h3 id="no_std"><a class="header" href="#no_std"><code>#![no_std]</code></a></h3>
<p><a href="https://crates.io/categories/no-std">Rust 스탠다드 라이브러리를 사용하지 않는 크레이트들</a>도 WebAssembly와 잘 작동하는 편입니다.</p>
<h3 id="파서-parser"><a class="header" href="#파서-parser">파서 (Parser)</a></h3>
<p>입력을 받고 I/O 작업을 수행하지 않는 이상, <a href="https://crates.io/categories/parser-implementations">파서들</a>은 보통 WebAssembly와 잘 작동하는 편입니다.</p>
<h3 id="텍스트-처리"><a class="header" href="#텍스트-처리">텍스트 처리</a></h3>
<p><a href="https://crates.io/categories/text-processing">인간 언어를 텍스트 형태로 나타냈을 때 발생하는 복잡성을 다루는 크레이트들</a>은 WebAssembly와 잘 작동하는 편입니다.</p>
<h3 id="rust-패턴"><a class="header" href="#rust-패턴">Rust 패턴</a></h3>
<p><a href="https://crates.io/categories/rust-patterns">Rust 프로그래밍의 특정한 상황에 쓰도록 공유되는 해결책들</a>은 WebAssembly와 잘 작동하는 편입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="다목적-크레이트가-webassembly를-지원하도록-코드-수정하기"><a class="header" href="#다목적-크레이트가-webassembly를-지원하도록-코드-수정하기">다목적 크레이트가 WebAssembly를 지원하도록 코드 수정하기</a></h1>
<p>이 섹션은 WebAssembly를 지원하는 데에 관심이 있는 다목적 크레이트 저자들을 위해 작성됐습니다.</p>
<h2 id="크레이트가-이미-webassembly를-지원할-수도-있어요"><a class="header" href="#크레이트가-이미-webassembly를-지원할-수도-있어요">크레이트가 이미 WebAssembly를 지원할 수도 있어요!</a></h2>
<p>우선 <a href="reference/./which-crates-work-with-wasm.html">어떤 작업을 하는 다목적 크레이트가 WebAssembly에 적합하지 <strong>않나요</strong>?</a> 의 내용을 먼저 읽어보세요. 작성하는 크레이트가 해당 사항이 없다면, WebAssembly를 지원할 확률이 높습니다.</p>
<p>추가로, 언제든 <code>cargo build</code> 명령어를 입력해서 WebAssembly 타겟을 지원하는지 확인해 볼 수 있습니다:</p>
<pre><code>cargo build --target wasm32-unknown-unknown
</code></pre>
<p>명령어 실행이 실패한다면 현재로서는 크레이트가 WebAssembly를 지원하지 않는다는 의미입니다. 하지만 이 명령어가 성공하더라도 크레이트가 꼭 WebAssembly를 지원한다는 의미는 아닙니다. 더 확실하게 확인하고 싶다면 <a href="reference/add-wasm-support-to-crate.html#maintaining-ongoing-support-for-webassembly">wasm 테스팅 코드를 추가하고 지속성 통합 (continuous integration) 환경에서 테스트를 실행해보기</a> 를 읽어보세요.</p>
<h2 id="webassembly-지원-추가하기"><a class="header" href="#webassembly-지원-추가하기">WebAssembly 지원 추가하기</a></h2>
<h3 id="바로-io를-수행하지-말아주세요"><a class="header" href="#바로-io를-수행하지-말아주세요">바로 I/O를 수행하지 말아주세요</a></h3>
<p>웹 환경에서 I/O는 항상 비동기적일 뿐 아니라 파일 시스템도 존재하지 않습니다. 라이브러리의 I/O를 분리하고 유저들이 I/O를 직접 수행하고 슬라이스를 라이브러리로 대신 입력할 수 있도록 수정해 봅시다.</p>
<p>예를 들어서, 이 코드를 리팩토링해 주세요:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::path::Path;

pub fn parse_thing(path: &amp;Path) -&gt; Result&lt;MyThing, MyError&gt; {
    let contents = fs::read(path)?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>다음은 리팩토링 된 코드입니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse_thing(contents: &amp;[u8]) -&gt; Result&lt;MyThing, MyError&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="wasm-bindgen을-종속성으로-추가하기"><a class="header" href="#wasm-bindgen을-종속성으로-추가하기"><code>wasm-bindgen</code>을 종속성으로 추가하기</a></h3>
<p>(예를 들어서, 라이브러리 사용자가 상호작용을 직접 컨트롤하도록 허용하면 안 되는 경우처럼) 외부 환경과 따로 상호작용을 해야 하는 경우, (필요하다면 <code>js-sys</code>와 <code>web-sys</code>와 함께) <code>wasm-bindgen</code>을 컴파일, 타겟팅 종속성으로 추가해야 합니다:</p>
<pre><code class="language-toml">[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = "0.3"
</code></pre>
<h3 id="동기적-io를-피해주세요"><a class="header" href="#동기적-io를-피해주세요">동기적 I/O를 피해주세요</a></h3>
<p>웹 환경에서는 비동기적 I/O만 수행할 수 있으므로 라이브러리에서 I/O 작업을 수행할 때는 동기적으로는 처리할 수 없습니다. <a href="https://crates.io/crates/futures"><code>futures</code> 크레이트</a> 와 <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/"><code>wasm-bindgen-futures</code> 크레이트</a>를 사용해서 비동기 I/O를 관리해 보세요. 라이브러리가 Future 타입 <code>F</code>를 제네릭 타입으로 사용한다면, 웹 환경의 <code>fetch</code>나 운영체제에서 제공하는 논블로킹 (non-blocking) I/O로 코드를 구현해 볼 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_stuff&lt;F&gt;(future: F) -&gt; impl Future&lt;Item = MyOtherThing&gt;
where
    F: Future&lt;Item = MyThing&gt;,
{
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>트레이트를 정의하고 WebAssembly와 웹, 네이티브 타겟에서 실행할 수 있도록 구현해 볼 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ReadMyThing {
    type F: Future&lt;Item = MyThing&gt;;
    fn read(&amp;self) -&gt; Self::F;
}

#[cfg(target_arch = "wasm32")]
struct WebReadMyThing {
    // ...
}

#[cfg(target_arch = "wasm32")]
impl ReadMyThing for WebReadMyThing {
    // ...
}

#[cfg(not(target_arch = "wasm32"))]
struct NativeReadMyThing {
    // ...
}

#[cfg(not(target_arch = "wasm32"))]
impl ReadMyThing for NativeReadMyThing {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="스레드-생성을-피해주세요"><a class="header" href="#스레드-생성을-피해주세요">스레드 생성을 피해주세요</a></h3>
<p>Wasm은 아직 스레드를 지원하지 않습니다. (하지만 <a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html">실험적으로 지원 작업이 진행되고 있긴 합니다.</a>) 그러므로, wasm에서 스레드를 생성하려고 시도하면 코드가 패닉하게 됩니다.</p>
<p><code>#[cfg(..)]</code>를 사용하여 타겟이 WebAssembly인지 아닌지 여부에 따라 스레드와 비스레드 코드를 따로 작성해 볼 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![cfg(target_arch = "wasm32")]
<span class="boring">fn main() {
</span>fn do_work() {
    // 이 스레드에서만 작업을 수행합니다...
}

#![cfg(not(target_arch = "wasm32"))]
fn do_work() {
    use std::thread;

    // 헬퍼 스레드를 사용해서 작업을 확장합니다...
    thread::spawn(|| {
        // ...
    });
}
<span class="boring">}</span></code></pre></pre>
<p>파일 I/O를 제거하고 유저들이 I/O 코드를 따로 가져올 수 있도록 허용하는 접근 방식과 유사하게, 스레드 생성 코드를 라이브러리에서 제외시킨 다음 유저들이 스레드 코드나 라이브러리를 따로 가져올 수 있도록 변경해 볼 수도 있습니다. 이렇게 구현했을 때 라이브러리 사용자들이 직접 스레드 풀 코드를 마련할 수 있게 되는 긍정적인 부수 효과를 보게 됩니다.</p>
<h2 id="webassembly의-지속적인-지원-유지하기"><a class="header" href="#webassembly의-지속적인-지원-유지하기">WebAssembly의 지속적인 지원 유지하기</a></h2>
<h3 id="지속성-통합-ci-환경을-사용해서-wasm32-unknown-unknown-타겟으로-빌드하기"><a class="header" href="#지속성-통합-ci-환경을-사용해서-wasm32-unknown-unknown-타겟으로-빌드하기">지속성 통합 (CI) 환경을 사용해서 <code>wasm32-unknown-unknown</code> 타겟으로 빌드하기</a></h3>
<p>WebAssembly를 타겟으로 할떄, 다음 명령어를 CI 스크립트에 포함시켜서 컴파일이 실패하지 않는 이유를 더 자세하게 확인할 수 있습니다:</p>
<pre><code>rustup target add wasm32-unknown-unknown
cargo check --target wasm32-unknown-unknown
</code></pre>
<p>예를 들어서, Travis CI 설정 파일인 <code>.travis.yml</code> 에 다음 내용을 추가해 보겠습니다:</p>
<pre><code class="language-yaml">
matrix:
  include:
    - language: rust
      rust: stable
      name: "check wasm32 support"
      install: rustup target add wasm32-unknown-unknown
      script: cargo check --target wasm32-unknown-unknown
</code></pre>
<h3 id="nodejs와-헤드리스-브라우저-headless-browsers-에서-테스팅하기"><a class="header" href="#nodejs와-헤드리스-브라우저-headless-browsers-에서-테스팅하기">Node.js와 <a href="https://ko.wikipedia.org/wiki/%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80">헤드리스 브라우저 (Headless Browsers)</a> 에서 테스팅하기</a></h3>
<p><code>wasm-bindgen-test</code>와 <code>wasm-pack-test</code> 하위 명령어 (subcommand) 를 사용해서 wasm 테스트들 Node.js나 헤드리스 브라우저에서 실행해보세요. 이러한 테스트들을 CI에 통합시켜 볼 수도 있습니다.</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">여기서 wasm 테스팅에 대해 더 알아보세요.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust로-작성한-webassembly-코드를-프로덕션-환경에-배포하기"><a class="header" href="#rust로-작성한-webassembly-코드를-프로덕션-환경에-배포하기">Rust로 작성한 WebAssembly 코드를 프로덕션 환경에 배포하기</a></h1>
<blockquote>
<p><strong>⚡ 사실 Rust, WebAssembly로 웹 앱을 작성했더라도 배포 과정이 다른 웹 앱을 배포하는 과정과 거의 동일합니다!</strong></p>
</blockquote>
<p>Rust로 생성한 WebAssembly를 실행하는 웹 앱을 배포해 보겠습니다. 빌드된 웹 앱을 프로덕션 서버의 파일 시스템으로 복사하고, 복사한 파일에 접근할 수 있도록 HTTP 서버를 설정해 주세요.</p>
<h2 id="http-서버가-applicationwasm-mime-타입을-지원하는지-확인해주세요"><a class="header" href="#http-서버가-applicationwasm-mime-타입을-지원하는지-확인해주세요">HTTP 서버가 <code>application/wasm</code> MIME 타입을 지원하는지 확인해주세요</a></h2>
<p>페이지가 빠르게 로드될 수 있도록, 네트워크 전송을 통해 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming"><code>WebAssembly.instantiateStreaming</code> 함수</a>를 사용하여 wasm 컴파일과 인스턴스화 과정을 파이프라인 처리해야 합니다. (번들러가 이 함수를 사용할 수 있는지도 확인해주세요.) 하지만 <code>instantiateStreaming</code>를 실행할 때 HTTP 응답이 <code>application/wasm</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 타입</a> 유형을 가지고 있지 않다면 오류가 발생하게 되니 이 부분도 잘 확인해  주세요.</p>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype">Apache HTTP 서버에서 MIME 타입 설정하기</a></li>
<li><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#types">NGINX HTTP 서버에서 MIME 타입 설정하기</a></li>
</ul>
<h2 id="추가-자료-2"><a class="header" href="#추가-자료-2">추가 자료</a></h2>
<ul>
<li><a href="https://webpack.js.org/guides/production/">프로덕션 개발 환경에서 Webpack를 사용하는 모범 사례.</a> 많은 Rust와 WebAssembly 프로젝트들은 Rust로 생성한 WebAssembly와 JavaScript, CSS, HTML 코드를 번들링 하기 위해 Webpack을 사용합니다. 이 가이드는 프로덕션 환경에 배포할 때 어떻게 Webpack을 가장 잘 활용할 수 있는지 알려주는 여러 유용한 정보들을 포함합니다.</li>
<li><a href="https://httpd.apache.org/docs/">Apache 문서.</a> Apache는 프로덕션 환경에서 많이 사용되는 HTTP 서버입니다.</li>
<li><a href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/">NGINX 문서.</a> NGNIX는 프로덕션 환경에서 많이 사용되는 HTTP 서버입니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="번역본-1"><a class="header" href="#번역본-1">번역본</a></h1>
<p>이 책을 다른 언어로 번역하는 데에 관심이 있다면 <a href="https://github.com/rustwasm/book">메인 레포지토리</a>를 포크하고 풀 리퀘스트를 생성해보세요.</p>
<ul>
<li><a href="https://github.com/pixelbracket/rust-wasm-book-ko">한국어</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
